{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, Optional, Inject, makeEnvironmentProviders, NgModule, InjectionToken } from '@angular/core';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport * as i1 from '@angular/common/http';\nimport { HttpHeaders, HttpParams, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { __awaiter } from 'tslib';\nimport { Subject, of, from, race, throwError, combineLatest, merge } from 'rxjs';\nimport { filter, tap, debounceTime, delay, switchMap, map, first, catchError, timeout, take, mergeMap } from 'rxjs/operators';\n/**\r\n * A validation handler that isn't validating nothing.\r\n * Can be used to skip validation (at your own risk).\r\n */\n\nclass NullValidationHandler {\n  validateSignature(validationParams) {\n    return Promise.resolve(null);\n  }\n\n  validateAtHash(validationParams) {\n    return Promise.resolve(true);\n  }\n\n}\n\nclass OAuthModuleConfig {}\n\nclass OAuthResourceServerConfig {}\n\nclass DateTimeProvider {}\n\nclass SystemDateTimeProvider extends DateTimeProvider {\n  now() {\n    return Date.now();\n  }\n\n  new() {\n    return new Date();\n  }\n\n}\n\nSystemDateTimeProvider.ɵfac = /* @__PURE__ */function () {\n  let ɵSystemDateTimeProvider_BaseFactory;\n  return function SystemDateTimeProvider_Factory(t) {\n    return (ɵSystemDateTimeProvider_BaseFactory || (ɵSystemDateTimeProvider_BaseFactory = i0.ɵɵgetInheritedFactory(SystemDateTimeProvider)))(t || SystemDateTimeProvider);\n  };\n}();\n\nSystemDateTimeProvider.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: SystemDateTimeProvider,\n  factory: SystemDateTimeProvider.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SystemDateTimeProvider, [{\n    type: Injectable\n  }], null, null);\n})();\n/**\r\n * Additional options that can be passed to tryLogin.\r\n */\n\n\nclass LoginOptions {\n  constructor() {\n    /**\r\n     * Set this to true to disable the nonce\r\n     * check which is used to avoid\r\n     * replay attacks.\r\n     * This flag should never be true in\r\n     * production environments.\r\n     */\n    this.disableNonceCheck = false;\n    /**\r\n     * Normally, you want to clear your hash fragment after\r\n     * the lib read the token(s) so that they are not displayed\r\n     * anymore in the url. If not, set this to true. For code flow\r\n     * this controls removing query string values.\r\n     */\n\n    this.preventClearHashAfterLogin = false;\n  }\n\n}\n/**\r\n * Defines the logging interface the OAuthService uses\r\n * internally. Is compatible with the `console` object,\r\n * but you can provide your own implementation as well\r\n * through dependency injection.\r\n */\n\n\nclass OAuthLogger {}\n/**\r\n * Defines a simple storage that can be used for\r\n * storing the tokens at client side.\r\n * Is compatible to localStorage and sessionStorage,\r\n * but you can also create your own implementations.\r\n */\n\n\nclass OAuthStorage {}\n\nclass MemoryStorage {\n  constructor() {\n    this.data = new Map();\n  }\n\n  getItem(key) {\n    return this.data.get(key);\n  }\n\n  removeItem(key) {\n    this.data.delete(key);\n  }\n\n  setItem(key, data) {\n    this.data.set(key, data);\n  }\n\n}\n\nMemoryStorage.ɵfac = function MemoryStorage_Factory(t) {\n  return new (t || MemoryStorage)();\n};\n\nMemoryStorage.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: MemoryStorage,\n  factory: MemoryStorage.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MemoryStorage, [{\n    type: Injectable\n  }], null, null);\n})();\n/**\r\n * Represents the received tokens, the received state\r\n * and the parsed claims from the id-token.\r\n */\n\n\nclass ReceivedTokens {}\n\nclass OAuthEvent {\n  constructor(type) {\n    this.type = type;\n  }\n\n}\n\nclass OAuthSuccessEvent extends OAuthEvent {\n  constructor(type, info = null) {\n    super(type);\n    this.info = info;\n  }\n\n}\n\nclass OAuthInfoEvent extends OAuthEvent {\n  constructor(type, info = null) {\n    super(type);\n    this.info = info;\n  }\n\n}\n\nclass OAuthErrorEvent extends OAuthEvent {\n  constructor(type, reason, params = null) {\n    super(type);\n    this.reason = reason;\n    this.params = params;\n  }\n\n} // see: https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#The_.22Unicode_Problem.22\n\n\nfunction b64DecodeUnicode(str) {\n  const base64 = str.replace(/\\-/g, '+').replace(/\\_/g, '/');\n  return decodeURIComponent(atob(base64).split('').map(function (c) {\n    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n  }).join(''));\n}\n\nfunction base64UrlEncode(str) {\n  const base64 = btoa(str);\n  return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nclass AuthConfig {\n  constructor(json) {\n    /**\r\n     * The client's id as registered with the auth server\r\n     */\n    this.clientId = '';\n    /**\r\n     * The client's redirectUri as registered with the auth server\r\n     */\n\n    this.redirectUri = '';\n    /**\r\n     * An optional second redirectUri where the auth server\r\n     * redirects the user to after logging out.\r\n     */\n\n    this.postLogoutRedirectUri = '';\n    /**\r\n     * Defines whether to use 'redirectUri' as a replacement\r\n     * of 'postLogoutRedirectUri' if the latter is not set.\r\n     */\n\n    this.redirectUriAsPostLogoutRedirectUriFallback = true;\n    /**\r\n     * The auth server's endpoint that allows to log\r\n     * the user in when using implicit flow.\r\n     */\n\n    this.loginUrl = '';\n    /**\r\n     * The requested scopes\r\n     */\n\n    this.scope = 'openid profile';\n    this.resource = '';\n    this.rngUrl = '';\n    /**\r\n     * Defines whether to use OpenId Connect during\r\n     * implicit flow.\r\n     */\n\n    this.oidc = true;\n    /**\r\n     * Defines whether to request an access token during\r\n     * implicit flow.\r\n     */\n\n    this.requestAccessToken = true;\n    this.options = null;\n    /**\r\n     * The issuer's uri.\r\n     */\n\n    this.issuer = '';\n    /**\r\n     * The logout url.\r\n     */\n\n    this.logoutUrl = '';\n    /**\r\n     * Defines whether to clear the hash fragment after logging in.\r\n     */\n\n    this.clearHashAfterLogin = true;\n    /**\r\n     * Url of the token endpoint as defined by OpenId Connect and OAuth 2.\r\n     */\n\n    this.tokenEndpoint = null;\n    /**\r\n     * Url of the revocation endpoint as defined by OpenId Connect and OAuth 2.\r\n     */\n\n    this.revocationEndpoint = null;\n    /**\r\n     * Names of known parameters sent out in the TokenResponse. https://tools.ietf.org/html/rfc6749#section-5.1\r\n     */\n\n    this.customTokenParameters = [];\n    /**\r\n     * Url of the userinfo endpoint as defined by OpenId Connect.\r\n     */\n\n    this.userinfoEndpoint = null;\n    this.responseType = '';\n    /**\r\n     * Defines whether additional debug information should\r\n     * be shown at the console. Note that in certain browsers\r\n     * the verbosity of the console needs to be explicitly set\r\n     * to include Debug level messages.\r\n     */\n\n    this.showDebugInformation = false;\n    /**\r\n     * The redirect uri used when doing silent refresh.\r\n     */\n\n    this.silentRefreshRedirectUri = '';\n    this.silentRefreshMessagePrefix = '';\n    /**\r\n     * Set this to true to display the iframe used for\r\n     * silent refresh for debugging.\r\n     */\n\n    this.silentRefreshShowIFrame = false;\n    /**\r\n     * Timeout for silent refresh.\r\n     * @internal\r\n     * depreacted b/c of typo, see silentRefreshTimeout\r\n     */\n\n    this.siletRefreshTimeout = 1000 * 20;\n    /**\r\n     * Timeout for silent refresh.\r\n     */\n\n    this.silentRefreshTimeout = 1000 * 20;\n    /**\r\n     * Some auth servers don't allow using password flow\r\n     * w/o a client secret while the standards do not\r\n     * demand for it. In this case, you can set a password\r\n     * here. As this password is exposed to the public\r\n     * it does not bring additional security and is therefore\r\n     * as good as using no password.\r\n     */\n\n    this.dummyClientSecret = '';\n    /**\r\n     * Defines whether https is required.\r\n     * The default value is remoteOnly which only allows\r\n     * http for localhost, while every other domains need\r\n     * to be used with https.\r\n     */\n\n    this.requireHttps = 'remoteOnly';\n    /**\r\n     * Defines whether every url provided by the discovery\r\n     * document has to start with the issuer's url.\r\n     */\n\n    this.strictDiscoveryDocumentValidation = true;\n    /**\r\n     * JSON Web Key Set (https://tools.ietf.org/html/rfc7517)\r\n     * with keys used to validate received id_tokens.\r\n     * This is taken out of the disovery document. Can be set manually too.\r\n     */\n\n    this.jwks = null;\n    /**\r\n     * Map with additional query parameter that are appended to\r\n     * the request when initializing implicit flow.\r\n     */\n\n    this.customQueryParams = null;\n    this.silentRefreshIFrameName = 'angular-oauth-oidc-silent-refresh-iframe';\n    /**\r\n     * Defines when the token_timeout event should be raised.\r\n     * If you set this to the default value 0.75, the event\r\n     * is triggered after 75% of the token's life time.\r\n     */\n\n    this.timeoutFactor = 0.75;\n    /**\r\n     * If true, the lib will try to check whether the user\r\n     * is still logged in on a regular basis as described\r\n     * in http://openid.net/specs/openid-connect-session-1_0.html#ChangeNotification\r\n     */\n\n    this.sessionChecksEnabled = false;\n    /**\r\n     * Interval in msec for checking the session\r\n     * according to http://openid.net/specs/openid-connect-session-1_0.html#ChangeNotification\r\n     */\n\n    this.sessionCheckIntervall = 3 * 1000;\n    /**\r\n     * Url for the iframe used for session checks\r\n     */\n\n    this.sessionCheckIFrameUrl = null;\n    /**\r\n     * Name of the iframe to use for session checks\r\n     */\n\n    this.sessionCheckIFrameName = 'angular-oauth-oidc-check-session-iframe';\n    /**\r\n     * This property has been introduced to disable at_hash checks\r\n     * and is indented for Identity Provider that does not deliver\r\n     * an at_hash EVEN THOUGH its recommended by the OIDC specs.\r\n     * Of course, when disabling these checks then we are bypassing\r\n     * a security check which means we are more vulnerable.\r\n     */\n\n    this.disableAtHashCheck = false;\n    /**\r\n     * Defines wether to check the subject of a refreshed token after silent refresh.\r\n     * Normally, it should be the same as before.\r\n     */\n\n    this.skipSubjectCheck = false;\n    this.useIdTokenHintForSilentRefresh = false;\n    /**\r\n     * Defined whether to skip the validation of the issuer in the discovery document.\r\n     * Normally, the discovey document's url starts with the url of the issuer.\r\n     */\n\n    this.skipIssuerCheck = false;\n    /**\r\n     * final state sent to issuer is built as follows:\r\n     * state = nonce + nonceStateSeparator + additional state\r\n     * Default separator is ';' (encoded %3B).\r\n     * In rare cases, this character might be forbidden or inconvenient to use by the issuer so it can be customized.\r\n     */\n\n    this.nonceStateSeparator = ';';\n    /**\r\n     * Set this to true to use HTTP BASIC auth for AJAX calls\r\n     */\n\n    this.useHttpBasicAuth = false;\n    /**\r\n     * Decreases the Expiration time of tokens by this number of seconds\r\n     */\n\n    this.decreaseExpirationBySec = 0;\n    /**\r\n     * The interceptors waits this time span if there is no token\r\n     */\n\n    this.waitForTokenInMsec = 0;\n    /**\r\n     * Code Flow is by defauld used together with PKCI which is also higly recommented.\r\n     * You can disbale it here by setting this flag to true.\r\n     * https://tools.ietf.org/html/rfc7636#section-1.1\r\n     */\n\n    this.disablePKCE = false;\n    /**\r\n     * Set this to true to preserve the requested route including query parameters after code flow login.\r\n     * This setting enables deep linking for the code flow.\r\n     */\n\n    this.preserveRequestedRoute = false;\n    /**\r\n     * Allows to disable the timer for the id_token used\r\n     * for token refresh\r\n     */\n\n    this.disableIdTokenTimer = false;\n    /**\r\n     * Blocks other origins requesting a silent refresh\r\n     */\n\n    this.checkOrigin = false;\n    /**\r\n     * This property allows you to override the method that is used to open the login url,\r\n     * allowing a way for implementations to specify their own method of routing to new\r\n     * urls.\r\n     */\n\n    this.openUri = uri => {\n      location.href = uri;\n    };\n\n    if (json) {\n      Object.assign(this, json);\n    }\n  }\n\n}\n/**\r\n * This custom encoder allows charactes like +, % and / to be used in passwords\r\n */\n\n\nclass WebHttpUrlEncodingCodec {\n  encodeKey(k) {\n    return encodeURIComponent(k);\n  }\n\n  encodeValue(v) {\n    return encodeURIComponent(v);\n  }\n\n  decodeKey(k) {\n    return decodeURIComponent(k);\n  }\n\n  decodeValue(v) {\n    return decodeURIComponent(v);\n  }\n\n}\n/**\r\n * Interface for Handlers that are hooked in to\r\n * validate tokens.\r\n */\n\n\nclass ValidationHandler {}\n/**\r\n * This abstract implementation of ValidationHandler already implements\r\n * the method validateAtHash. However, to make use of it,\r\n * you have to override the method calcHash.\r\n */\n\n\nclass AbstractValidationHandler {\n  /**\r\n   * Validates the at_hash in an id_token against the received access_token.\r\n   */\n  validateAtHash(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let hashAlg = this.inferHashAlgorithm(params.idTokenHeader);\n      let tokenHash = yield this.calcHash(params.accessToken, hashAlg); // sha256(accessToken, { asString: true });\n\n      let leftMostHalf = tokenHash.substr(0, tokenHash.length / 2);\n      let atHash = base64UrlEncode(leftMostHalf);\n      let claimsAtHash = params.idTokenClaims['at_hash'].replace(/=/g, '');\n\n      if (atHash !== claimsAtHash) {\n        console.error('exptected at_hash: ' + atHash);\n        console.error('actual at_hash: ' + claimsAtHash);\n      }\n\n      return atHash === claimsAtHash;\n    });\n  }\n  /**\r\n   * Infers the name of the hash algorithm to use\r\n   * from the alg field of an id_token.\r\n   *\r\n   * @param jwtHeader the id_token's parsed header\r\n   */\n\n\n  inferHashAlgorithm(jwtHeader) {\n    let alg = jwtHeader['alg'];\n\n    if (!alg.match(/^.S[0-9]{3}$/)) {\n      throw new Error('Algorithm not supported: ' + alg);\n    }\n\n    return 'sha-' + alg.substr(2);\n  }\n\n}\n\nclass UrlHelperService {\n  getHashFragmentParams(customHashFragment) {\n    let hash = customHashFragment || window.location.hash;\n    hash = decodeURIComponent(hash);\n\n    if (hash.indexOf('#') !== 0) {\n      return {};\n    }\n\n    const questionMarkPosition = hash.indexOf('?');\n\n    if (questionMarkPosition > -1) {\n      hash = hash.substr(questionMarkPosition + 1);\n    } else {\n      hash = hash.substr(1);\n    }\n\n    return this.parseQueryString(hash);\n  }\n\n  parseQueryString(queryString) {\n    const data = {};\n    let pairs, pair, separatorIndex, escapedKey, escapedValue, key, value;\n\n    if (queryString === null) {\n      return data;\n    }\n\n    pairs = queryString.split('&');\n\n    for (let i = 0; i < pairs.length; i++) {\n      pair = pairs[i];\n      separatorIndex = pair.indexOf('=');\n\n      if (separatorIndex === -1) {\n        escapedKey = pair;\n        escapedValue = null;\n      } else {\n        escapedKey = pair.substr(0, separatorIndex);\n        escapedValue = pair.substr(separatorIndex + 1);\n      }\n\n      key = decodeURIComponent(escapedKey);\n      value = decodeURIComponent(escapedValue);\n\n      if (key.substr(0, 1) === '/') {\n        key = key.substr(1);\n      }\n\n      data[key] = value;\n    }\n\n    return data;\n  }\n\n}\n\nUrlHelperService.ɵfac = function UrlHelperService_Factory(t) {\n  return new (t || UrlHelperService)();\n};\n\nUrlHelperService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: UrlHelperService,\n  factory: UrlHelperService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(UrlHelperService, [{\n    type: Injectable\n  }], null, null);\n})(); // Credits: https://github.com/dchest/fast-sha256-js/tree/master/src\n// We add this lib directly b/c the published version of fast-sha256-js\n// is commonjs and hence leads to a warning about tree-shakability emitted\n// by the Angular CLI\n// SHA-256 (+ HMAC and PBKDF2) for JavaScript.\n//\n// Written in 2014-2016 by Dmitry Chestnykh.\n// Public domain, no warranty.\n//\n// Functions (accept and return Uint8Arrays):\n//\n//   sha256(message) -> hash\n//   sha256.hmac(key, message) -> mac\n//   sha256.pbkdf2(password, salt, rounds, dkLen) -> dk\n//\n//  Classes:\n//\n//   new sha256.Hash()\n//   new sha256.HMAC(key)\n//\n\n\nconst digestLength = 32;\nconst blockSize = 64; // SHA-256 constants\n\nconst K = new Uint32Array([0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]);\n\nfunction hashBlocks(w, v, p, pos, len) {\n  let a, b, c, d, e, f, g, h, u, i, j, t1, t2;\n\n  while (len >= 64) {\n    a = v[0];\n    b = v[1];\n    c = v[2];\n    d = v[3];\n    e = v[4];\n    f = v[5];\n    g = v[6];\n    h = v[7];\n\n    for (i = 0; i < 16; i++) {\n      j = pos + i * 4;\n      w[i] = (p[j] & 0xff) << 24 | (p[j + 1] & 0xff) << 16 | (p[j + 2] & 0xff) << 8 | p[j + 3] & 0xff;\n    }\n\n    for (i = 16; i < 64; i++) {\n      u = w[i - 2];\n      t1 = (u >>> 17 | u << 32 - 17) ^ (u >>> 19 | u << 32 - 19) ^ u >>> 10;\n      u = w[i - 15];\n      t2 = (u >>> 7 | u << 32 - 7) ^ (u >>> 18 | u << 32 - 18) ^ u >>> 3;\n      w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0);\n    }\n\n    for (i = 0; i < 64; i++) {\n      t1 = (((e >>> 6 | e << 32 - 6) ^ (e >>> 11 | e << 32 - 11) ^ (e >>> 25 | e << 32 - 25)) + (e & f ^ ~e & g) | 0) + (h + (K[i] + w[i] | 0) | 0) | 0;\n      t2 = ((a >>> 2 | a << 32 - 2) ^ (a >>> 13 | a << 32 - 13) ^ (a >>> 22 | a << 32 - 22)) + (a & b ^ a & c ^ b & c) | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t1 | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t1 + t2 | 0;\n    }\n\n    v[0] += a;\n    v[1] += b;\n    v[2] += c;\n    v[3] += d;\n    v[4] += e;\n    v[5] += f;\n    v[6] += g;\n    v[7] += h;\n    pos += 64;\n    len -= 64;\n  }\n\n  return pos;\n} // Hash implements SHA256 hash algorithm.\n\n\nclass Hash {\n  constructor() {\n    this.digestLength = digestLength;\n    this.blockSize = blockSize; // Note: Int32Array is used instead of Uint32Array for performance reasons.\n\n    this.state = new Int32Array(8); // hash state\n\n    this.temp = new Int32Array(64); // temporary state\n\n    this.buffer = new Uint8Array(128); // buffer for data to hash\n\n    this.bufferLength = 0; // number of bytes in buffer\n\n    this.bytesHashed = 0; // number of total bytes hashed\n\n    this.finished = false; // indicates whether the hash was finalized\n\n    this.reset();\n  } // Resets hash state making it possible\n  // to re-use this instance to hash other data.\n\n\n  reset() {\n    this.state[0] = 0x6a09e667;\n    this.state[1] = 0xbb67ae85;\n    this.state[2] = 0x3c6ef372;\n    this.state[3] = 0xa54ff53a;\n    this.state[4] = 0x510e527f;\n    this.state[5] = 0x9b05688c;\n    this.state[6] = 0x1f83d9ab;\n    this.state[7] = 0x5be0cd19;\n    this.bufferLength = 0;\n    this.bytesHashed = 0;\n    this.finished = false;\n    return this;\n  } // Cleans internal buffers and re-initializes hash state.\n\n\n  clean() {\n    for (let i = 0; i < this.buffer.length; i++) {\n      this.buffer[i] = 0;\n    }\n\n    for (let i = 0; i < this.temp.length; i++) {\n      this.temp[i] = 0;\n    }\n\n    this.reset();\n  } // Updates hash state with the given data.\n  //\n  // Optionally, length of the data can be specified to hash\n  // fewer bytes than data.length.\n  //\n  // Throws error when trying to update already finalized hash:\n  // instance must be reset to use it again.\n\n\n  update(data, dataLength = data.length) {\n    if (this.finished) {\n      throw new Error(\"SHA256: can't update because hash was finished.\");\n    }\n\n    let dataPos = 0;\n    this.bytesHashed += dataLength;\n\n    if (this.bufferLength > 0) {\n      while (this.bufferLength < 64 && dataLength > 0) {\n        this.buffer[this.bufferLength++] = data[dataPos++];\n        dataLength--;\n      }\n\n      if (this.bufferLength === 64) {\n        hashBlocks(this.temp, this.state, this.buffer, 0, 64);\n        this.bufferLength = 0;\n      }\n    }\n\n    if (dataLength >= 64) {\n      dataPos = hashBlocks(this.temp, this.state, data, dataPos, dataLength);\n      dataLength %= 64;\n    }\n\n    while (dataLength > 0) {\n      this.buffer[this.bufferLength++] = data[dataPos++];\n      dataLength--;\n    }\n\n    return this;\n  } // Finalizes hash state and puts hash into out.\n  //\n  // If hash was already finalized, puts the same value.\n\n\n  finish(out) {\n    if (!this.finished) {\n      const bytesHashed = this.bytesHashed;\n      const left = this.bufferLength;\n      const bitLenHi = bytesHashed / 0x20000000 | 0;\n      const bitLenLo = bytesHashed << 3;\n      const padLength = bytesHashed % 64 < 56 ? 64 : 128;\n      this.buffer[left] = 0x80;\n\n      for (let i = left + 1; i < padLength - 8; i++) {\n        this.buffer[i] = 0;\n      }\n\n      this.buffer[padLength - 8] = bitLenHi >>> 24 & 0xff;\n      this.buffer[padLength - 7] = bitLenHi >>> 16 & 0xff;\n      this.buffer[padLength - 6] = bitLenHi >>> 8 & 0xff;\n      this.buffer[padLength - 5] = bitLenHi >>> 0 & 0xff;\n      this.buffer[padLength - 4] = bitLenLo >>> 24 & 0xff;\n      this.buffer[padLength - 3] = bitLenLo >>> 16 & 0xff;\n      this.buffer[padLength - 2] = bitLenLo >>> 8 & 0xff;\n      this.buffer[padLength - 1] = bitLenLo >>> 0 & 0xff;\n      hashBlocks(this.temp, this.state, this.buffer, 0, padLength);\n      this.finished = true;\n    }\n\n    for (let i = 0; i < 8; i++) {\n      out[i * 4 + 0] = this.state[i] >>> 24 & 0xff;\n      out[i * 4 + 1] = this.state[i] >>> 16 & 0xff;\n      out[i * 4 + 2] = this.state[i] >>> 8 & 0xff;\n      out[i * 4 + 3] = this.state[i] >>> 0 & 0xff;\n    }\n\n    return this;\n  } // Returns the final hash digest.\n\n\n  digest() {\n    const out = new Uint8Array(this.digestLength);\n    this.finish(out);\n    return out;\n  } // Internal function for use in HMAC for optimization.\n\n\n  _saveState(out) {\n    for (let i = 0; i < this.state.length; i++) {\n      out[i] = this.state[i];\n    }\n  } // Internal function for use in HMAC for optimization.\n\n\n  _restoreState(from, bytesHashed) {\n    for (let i = 0; i < this.state.length; i++) {\n      this.state[i] = from[i];\n    }\n\n    this.bytesHashed = bytesHashed;\n    this.finished = false;\n    this.bufferLength = 0;\n  }\n\n} // HMAC implements HMAC-SHA256 message authentication algorithm.\n\n\nclass HMAC {\n  constructor(key) {\n    this.inner = new Hash();\n    this.outer = new Hash();\n    this.blockSize = this.inner.blockSize;\n    this.digestLength = this.inner.digestLength;\n    const pad = new Uint8Array(this.blockSize);\n\n    if (key.length > this.blockSize) {\n      new Hash().update(key).finish(pad).clean();\n    } else {\n      for (let i = 0; i < key.length; i++) {\n        pad[i] = key[i];\n      }\n    }\n\n    for (let i = 0; i < pad.length; i++) {\n      pad[i] ^= 0x36;\n    }\n\n    this.inner.update(pad);\n\n    for (let i = 0; i < pad.length; i++) {\n      pad[i] ^= 0x36 ^ 0x5c;\n    }\n\n    this.outer.update(pad);\n    this.istate = new Uint32Array(8);\n    this.ostate = new Uint32Array(8);\n\n    this.inner._saveState(this.istate);\n\n    this.outer._saveState(this.ostate);\n\n    for (let i = 0; i < pad.length; i++) {\n      pad[i] = 0;\n    }\n  } // Returns HMAC state to the state initialized with key\n  // to make it possible to run HMAC over the other data with the same\n  // key without creating a new instance.\n\n\n  reset() {\n    this.inner._restoreState(this.istate, this.inner.blockSize);\n\n    this.outer._restoreState(this.ostate, this.outer.blockSize);\n\n    return this;\n  } // Cleans HMAC state.\n\n\n  clean() {\n    for (let i = 0; i < this.istate.length; i++) {\n      this.ostate[i] = this.istate[i] = 0;\n    }\n\n    this.inner.clean();\n    this.outer.clean();\n  } // Updates state with provided data.\n\n\n  update(data) {\n    this.inner.update(data);\n    return this;\n  } // Finalizes HMAC and puts the result in out.\n\n\n  finish(out) {\n    if (this.outer.finished) {\n      this.outer.finish(out);\n    } else {\n      this.inner.finish(out);\n      this.outer.update(out, this.digestLength).finish(out);\n    }\n\n    return this;\n  } // Returns message authentication code.\n\n\n  digest() {\n    const out = new Uint8Array(this.digestLength);\n    this.finish(out);\n    return out;\n  }\n\n} // Returns SHA256 hash of data.\n\n\nfunction hash(data) {\n  const h = new Hash().update(data);\n  const digest = h.digest();\n  h.clean();\n  return digest;\n} // Returns HMAC-SHA256 of data under the key.\n\n\nfunction hmac(key, data) {\n  const h = new HMAC(key).update(data);\n  const digest = h.digest();\n  h.clean();\n  return digest;\n} // Fills hkdf buffer like this:\n// T(1) = HMAC-Hash(PRK, T(0) | info | 0x01)\n\n\nfunction fillBuffer(buffer, hmac, info, counter) {\n  // Counter is a byte value: check if it overflowed.\n  const num = counter[0];\n\n  if (num === 0) {\n    throw new Error('hkdf: cannot expand more');\n  } // Prepare HMAC instance for new data with old key.\n\n\n  hmac.reset(); // Hash in previous output if it was generated\n  // (i.e. counter is greater than 1).\n\n  if (num > 1) {\n    hmac.update(buffer);\n  } // Hash in info if it exists.\n\n\n  if (info) {\n    hmac.update(info);\n  } // Hash in the counter.\n\n\n  hmac.update(counter); // Output result to buffer and clean HMAC instance.\n\n  hmac.finish(buffer); // Increment counter inside typed array, this works properly.\n\n  counter[0]++;\n}\n\nconst hkdfSalt = new Uint8Array(digestLength); // Filled with zeroes.\n\nfunction hkdf(key, salt = hkdfSalt, info, length = 32) {\n  const counter = new Uint8Array([1]); // HKDF-Extract uses salt as HMAC key, and key as data.\n\n  const okm = hmac(salt, key); // Initialize HMAC for expanding with extracted key.\n  // Ensure no collisions with `hmac` function.\n\n  const hmac_ = new HMAC(okm); // Allocate buffer.\n\n  const buffer = new Uint8Array(hmac_.digestLength);\n  let bufpos = buffer.length;\n  const out = new Uint8Array(length);\n\n  for (let i = 0; i < length; i++) {\n    if (bufpos === buffer.length) {\n      fillBuffer(buffer, hmac_, info, counter);\n      bufpos = 0;\n    }\n\n    out[i] = buffer[bufpos++];\n  }\n\n  hmac_.clean();\n  buffer.fill(0);\n  counter.fill(0);\n  return out;\n} // Derives a key from password and salt using PBKDF2-HMAC-SHA256\n// with the given number of iterations.\n//\n// The number of bytes returned is equal to dkLen.\n//\n// (For better security, avoid dkLen greater than hash length - 32 bytes).\n\n\nfunction pbkdf2(password, salt, iterations, dkLen) {\n  const prf = new HMAC(password);\n  const len = prf.digestLength;\n  const ctr = new Uint8Array(4);\n  const t = new Uint8Array(len);\n  const u = new Uint8Array(len);\n  const dk = new Uint8Array(dkLen);\n\n  for (let i = 0; i * len < dkLen; i++) {\n    let c = i + 1;\n    ctr[0] = c >>> 24 & 0xff;\n    ctr[1] = c >>> 16 & 0xff;\n    ctr[2] = c >>> 8 & 0xff;\n    ctr[3] = c >>> 0 & 0xff;\n    prf.reset();\n    prf.update(salt);\n    prf.update(ctr);\n    prf.finish(u);\n\n    for (let j = 0; j < len; j++) {\n      t[j] = u[j];\n    }\n\n    for (let j = 2; j <= iterations; j++) {\n      prf.reset();\n      prf.update(u).finish(u);\n\n      for (let k = 0; k < len; k++) {\n        t[k] ^= u[k];\n      }\n    }\n\n    for (let j = 0; j < len && i * len + j < dkLen; j++) {\n      dk[i * len + j] = t[j];\n    }\n  }\n\n  for (let i = 0; i < len; i++) {\n    t[i] = u[i] = 0;\n  }\n\n  for (let i = 0; i < 4; i++) {\n    ctr[i] = 0;\n  }\n\n  prf.clean();\n  return dk;\n}\n/**\r\n * Abstraction for crypto algorithms\r\n */\n\n\nclass HashHandler {}\n\nfunction decodeUTF8(s) {\n  if (typeof s !== 'string') throw new TypeError('expected string');\n  var i,\n      d = s,\n      b = new Uint8Array(d.length);\n\n  for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);\n\n  return b;\n}\n\nfunction encodeUTF8(arr) {\n  var i,\n      s = [];\n\n  for (i = 0; i < arr.length; i++) s.push(String.fromCharCode(arr[i]));\n\n  return s.join('');\n}\n\nclass DefaultHashHandler {\n  calcHash(valueToHash, algorithm) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // const encoder = new TextEncoder();\n      // const hashArray = await window.crypto.subtle.digest(algorithm, data);\n      // const data = encoder.encode(valueToHash);\n      // const fhash = fsha256(valueToHash);\n      const candHash = encodeUTF8(hash(decodeUTF8(valueToHash))); // const hashArray = (sha256 as any).array(valueToHash);\n      // // const hashString = this.toHashString(hashArray);\n      // const hashString = this.toHashString2(hashArray);\n      // console.debug('hash orig - cand', candHash, hashString);\n      // alert(1);\n\n      return candHash;\n    });\n  }\n\n  toHashString2(byteArray) {\n    let result = '';\n\n    for (let e of byteArray) {\n      result += String.fromCharCode(e);\n    }\n\n    return result;\n  }\n\n  toHashString(buffer) {\n    const byteArray = new Uint8Array(buffer);\n    let result = '';\n\n    for (let e of byteArray) {\n      result += String.fromCharCode(e);\n    }\n\n    return result;\n  }\n\n}\n\nDefaultHashHandler.ɵfac = function DefaultHashHandler_Factory(t) {\n  return new (t || DefaultHashHandler)();\n};\n\nDefaultHashHandler.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DefaultHashHandler,\n  factory: DefaultHashHandler.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DefaultHashHandler, [{\n    type: Injectable\n  }], null, null);\n})();\n/**\r\n * Service for logging in and logging out with\r\n * OIDC and OAuth2. Supports implicit flow and\r\n * password flow.\r\n */\n\n\nclass OAuthService extends AuthConfig {\n  constructor(ngZone, http, storage, tokenValidationHandler, config, urlHelper, logger, crypto, document, dateTimeService) {\n    var _a;\n\n    super();\n    this.ngZone = ngZone;\n    this.http = http;\n    this.config = config;\n    this.urlHelper = urlHelper;\n    this.logger = logger;\n    this.crypto = crypto;\n    this.dateTimeService = dateTimeService;\n    /**\r\n     * @internal\r\n     * Deprecated:  use property events instead\r\n     */\n\n    this.discoveryDocumentLoaded = false;\n    /**\r\n     * The received (passed around) state, when logging\r\n     * in with implicit flow.\r\n     */\n\n    this.state = '';\n    this.eventsSubject = new Subject();\n    this.discoveryDocumentLoadedSubject = new Subject();\n    this.grantTypesSupported = [];\n    this.inImplicitFlow = false;\n    this.saveNoncesInLocalStorage = false;\n    this.debug('angular-oauth2-oidc v10'); // See https://github.com/manfredsteyer/angular-oauth2-oidc/issues/773 for why this is needed\n\n    this.document = document;\n\n    if (!config) {\n      config = {};\n    }\n\n    this.discoveryDocumentLoaded$ = this.discoveryDocumentLoadedSubject.asObservable();\n    this.events = this.eventsSubject.asObservable();\n\n    if (tokenValidationHandler) {\n      this.tokenValidationHandler = tokenValidationHandler;\n    }\n\n    if (config) {\n      this.configure(config);\n    }\n\n    try {\n      if (storage) {\n        this.setStorage(storage);\n      } else if (typeof sessionStorage !== 'undefined') {\n        this.setStorage(sessionStorage);\n      }\n    } catch (e) {\n      console.error('No OAuthStorage provided and cannot access default (sessionStorage).' + 'Consider providing a custom OAuthStorage implementation in your module.', e);\n    } // in IE, sessionStorage does not always survive a redirect\n\n\n    if (this.checkLocalStorageAccessable()) {\n      const ua = (_a = window === null || window === void 0 ? void 0 : window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent;\n      const msie = (ua === null || ua === void 0 ? void 0 : ua.includes('MSIE ')) || (ua === null || ua === void 0 ? void 0 : ua.includes('Trident'));\n\n      if (msie) {\n        this.saveNoncesInLocalStorage = true;\n      }\n    }\n\n    this.setupRefreshTimer();\n  }\n\n  checkLocalStorageAccessable() {\n    if (typeof window === 'undefined') return false;\n    const test = 'test';\n\n    try {\n      if (typeof window['localStorage'] === 'undefined') return false;\n      localStorage.setItem(test, test);\n      localStorage.removeItem(test);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  /**\r\n   * Use this method to configure the service\r\n   * @param config the configuration\r\n   */\n\n\n  configure(config) {\n    // For the sake of downward compatibility with\n    // original configuration API\n    Object.assign(this, new AuthConfig(), config);\n    this.config = Object.assign({}, new AuthConfig(), config);\n\n    if (this.sessionChecksEnabled) {\n      this.setupSessionCheck();\n    }\n\n    this.configChanged();\n  }\n\n  configChanged() {\n    this.setupRefreshTimer();\n  }\n\n  restartSessionChecksIfStillLoggedIn() {\n    if (this.hasValidIdToken()) {\n      this.initSessionCheck();\n    }\n  }\n\n  restartRefreshTimerIfStillLoggedIn() {\n    this.setupExpirationTimers();\n  }\n\n  setupSessionCheck() {\n    this.events.pipe(filter(e => e.type === 'token_received')).subscribe(e => {\n      this.initSessionCheck();\n    });\n  }\n  /**\r\n   * Will setup up silent refreshing for when the token is\r\n   * about to expire. When the user is logged out via this.logOut method, the\r\n   * silent refreshing will pause and not refresh the tokens until the user is\r\n   * logged back in via receiving a new token.\r\n   * @param params Additional parameter to pass\r\n   * @param listenTo Setup automatic refresh of a specific token type\r\n   */\n\n\n  setupAutomaticSilentRefresh(params = {}, listenTo, noPrompt = true) {\n    let shouldRunSilentRefresh = true;\n    this.clearAutomaticRefreshTimer();\n    this.automaticRefreshSubscription = this.events.pipe(tap(e => {\n      if (e.type === 'token_received') {\n        shouldRunSilentRefresh = true;\n      } else if (e.type === 'logout') {\n        shouldRunSilentRefresh = false;\n      }\n    }), filter(e => e.type === 'token_expires' && (listenTo == null || listenTo === 'any' || e.info === listenTo)), debounceTime(1000)).subscribe(_ => {\n      if (shouldRunSilentRefresh) {\n        // this.silentRefresh(params, noPrompt).catch(_ => {\n        this.refreshInternal(params, noPrompt).catch(_ => {\n          this.debug('Automatic silent refresh did not work');\n        });\n      }\n    });\n    this.restartRefreshTimerIfStillLoggedIn();\n  }\n\n  refreshInternal(params, noPrompt) {\n    if (!this.useSilentRefresh && this.responseType === 'code') {\n      return this.refreshToken();\n    } else {\n      return this.silentRefresh(params, noPrompt);\n    }\n  }\n  /**\r\n   * Convenience method that first calls `loadDiscoveryDocument(...)` and\r\n   * directly chains using the `then(...)` part of the promise to call\r\n   * the `tryLogin(...)` method.\r\n   *\r\n   * @param options LoginOptions to pass through to `tryLogin(...)`\r\n   */\n\n\n  loadDiscoveryDocumentAndTryLogin(options = null) {\n    return this.loadDiscoveryDocument().then(doc => {\n      return this.tryLogin(options);\n    });\n  }\n  /**\r\n   * Convenience method that first calls `loadDiscoveryDocumentAndTryLogin(...)`\r\n   * and if then chains to `initLoginFlow()`, but only if there is no valid\r\n   * IdToken or no valid AccessToken.\r\n   *\r\n   * @param options LoginOptions to pass through to `tryLogin(...)`\r\n   */\n\n\n  loadDiscoveryDocumentAndLogin(options = null) {\n    options = options || {};\n    return this.loadDiscoveryDocumentAndTryLogin(options).then(_ => {\n      if (!this.hasValidIdToken() || !this.hasValidAccessToken()) {\n        const state = typeof options.state === 'string' ? options.state : '';\n        this.initLoginFlow(state);\n        return false;\n      } else {\n        return true;\n      }\n    });\n  }\n\n  debug(...args) {\n    if (this.showDebugInformation) {\n      this.logger.debug.apply(this.logger, args);\n    }\n  }\n\n  validateUrlFromDiscoveryDocument(url) {\n    const errors = [];\n    const httpsCheck = this.validateUrlForHttps(url);\n    const issuerCheck = this.validateUrlAgainstIssuer(url);\n\n    if (!httpsCheck) {\n      errors.push('https for all urls required. Also for urls received by discovery.');\n    }\n\n    if (!issuerCheck) {\n      errors.push('Every url in discovery document has to start with the issuer url.' + 'Also see property strictDiscoveryDocumentValidation.');\n    }\n\n    return errors;\n  }\n\n  validateUrlForHttps(url) {\n    if (!url) {\n      return true;\n    }\n\n    const lcUrl = url.toLowerCase();\n\n    if (this.requireHttps === false) {\n      return true;\n    }\n\n    if ((lcUrl.match(/^http:\\/\\/localhost($|[:\\/])/) || lcUrl.match(/^http:\\/\\/localhost($|[:\\/])/)) && this.requireHttps === 'remoteOnly') {\n      return true;\n    }\n\n    return lcUrl.startsWith('https://');\n  }\n\n  assertUrlNotNullAndCorrectProtocol(url, description) {\n    if (!url) {\n      throw new Error(`'${description}' should not be null`);\n    }\n\n    if (!this.validateUrlForHttps(url)) {\n      throw new Error(`'${description}' must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).`);\n    }\n  }\n\n  validateUrlAgainstIssuer(url) {\n    if (!this.strictDiscoveryDocumentValidation) {\n      return true;\n    }\n\n    if (!url) {\n      return true;\n    }\n\n    return url.toLowerCase().startsWith(this.issuer.toLowerCase());\n  }\n\n  setupRefreshTimer() {\n    if (typeof window === 'undefined') {\n      this.debug('timer not supported on this plattform');\n      return;\n    }\n\n    if (this.hasValidIdToken() || this.hasValidAccessToken()) {\n      this.clearAccessTokenTimer();\n      this.clearIdTokenTimer();\n      this.setupExpirationTimers();\n    }\n\n    if (this.tokenReceivedSubscription) this.tokenReceivedSubscription.unsubscribe();\n    this.tokenReceivedSubscription = this.events.pipe(filter(e => e.type === 'token_received')).subscribe(_ => {\n      this.clearAccessTokenTimer();\n      this.clearIdTokenTimer();\n      this.setupExpirationTimers();\n    });\n  }\n\n  setupExpirationTimers() {\n    if (this.hasValidAccessToken()) {\n      this.setupAccessTokenTimer();\n    }\n\n    if (!this.disableIdTokenTimer && this.hasValidIdToken()) {\n      this.setupIdTokenTimer();\n    }\n  }\n\n  setupAccessTokenTimer() {\n    const expiration = this.getAccessTokenExpiration();\n    const storedAt = this.getAccessTokenStoredAt();\n    const timeout = this.calcTimeout(storedAt, expiration);\n    this.ngZone.runOutsideAngular(() => {\n      this.accessTokenTimeoutSubscription = of(new OAuthInfoEvent('token_expires', 'access_token')).pipe(delay(timeout)).subscribe(e => {\n        this.ngZone.run(() => {\n          this.eventsSubject.next(e);\n        });\n      });\n    });\n  }\n\n  setupIdTokenTimer() {\n    const expiration = this.getIdTokenExpiration();\n    const storedAt = this.getIdTokenStoredAt();\n    const timeout = this.calcTimeout(storedAt, expiration);\n    this.ngZone.runOutsideAngular(() => {\n      this.idTokenTimeoutSubscription = of(new OAuthInfoEvent('token_expires', 'id_token')).pipe(delay(timeout)).subscribe(e => {\n        this.ngZone.run(() => {\n          this.eventsSubject.next(e);\n        });\n      });\n    });\n  }\n  /**\r\n   * Stops timers for automatic refresh.\r\n   * To restart it, call setupAutomaticSilentRefresh again.\r\n   */\n\n\n  stopAutomaticRefresh() {\n    this.clearAccessTokenTimer();\n    this.clearIdTokenTimer();\n    this.clearAutomaticRefreshTimer();\n  }\n\n  clearAccessTokenTimer() {\n    if (this.accessTokenTimeoutSubscription) {\n      this.accessTokenTimeoutSubscription.unsubscribe();\n    }\n  }\n\n  clearIdTokenTimer() {\n    if (this.idTokenTimeoutSubscription) {\n      this.idTokenTimeoutSubscription.unsubscribe();\n    }\n  }\n\n  clearAutomaticRefreshTimer() {\n    if (this.automaticRefreshSubscription) {\n      this.automaticRefreshSubscription.unsubscribe();\n    }\n  }\n\n  calcTimeout(storedAt, expiration) {\n    const now = this.dateTimeService.now();\n    const delta = (expiration - storedAt) * this.timeoutFactor - (now - storedAt);\n    const duration = Math.max(0, delta);\n    const maxTimeoutValue = 2147483647;\n    return duration > maxTimeoutValue ? maxTimeoutValue : duration;\n  }\n  /**\r\n   * DEPRECATED. Use a provider for OAuthStorage instead:\r\n   *\r\n   * { provide: OAuthStorage, useFactory: oAuthStorageFactory }\r\n   * export function oAuthStorageFactory(): OAuthStorage { return localStorage; }\r\n   * Sets a custom storage used to store the received\r\n   * tokens on client side. By default, the browser's\r\n   * sessionStorage is used.\r\n   * @ignore\r\n   *\r\n   * @param storage\r\n   */\n\n\n  setStorage(storage) {\n    this._storage = storage;\n    this.configChanged();\n  }\n  /**\r\n   * Loads the discovery document to configure most\r\n   * properties of this service. The url of the discovery\r\n   * document is infered from the issuer's url according\r\n   * to the OpenId Connect spec. To use another url you\r\n   * can pass it to to optional parameter fullUrl.\r\n   *\r\n   * @param fullUrl\r\n   */\n\n\n  loadDiscoveryDocument(fullUrl = null) {\n    return new Promise((resolve, reject) => {\n      if (!fullUrl) {\n        fullUrl = this.issuer || '';\n\n        if (!fullUrl.endsWith('/')) {\n          fullUrl += '/';\n        }\n\n        fullUrl += '.well-known/openid-configuration';\n      }\n\n      if (!this.validateUrlForHttps(fullUrl)) {\n        reject(\"issuer  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\");\n        return;\n      }\n\n      this.http.get(fullUrl).subscribe(doc => {\n        if (!this.validateDiscoveryDocument(doc)) {\n          this.eventsSubject.next(new OAuthErrorEvent('discovery_document_validation_error', null));\n          reject('discovery_document_validation_error');\n          return;\n        }\n\n        this.loginUrl = doc.authorization_endpoint;\n        this.logoutUrl = doc.end_session_endpoint || this.logoutUrl;\n        this.grantTypesSupported = doc.grant_types_supported;\n        this.issuer = doc.issuer;\n        this.tokenEndpoint = doc.token_endpoint;\n        this.userinfoEndpoint = doc.userinfo_endpoint || this.userinfoEndpoint;\n        this.jwksUri = doc.jwks_uri;\n        this.sessionCheckIFrameUrl = doc.check_session_iframe || this.sessionCheckIFrameUrl;\n        this.discoveryDocumentLoaded = true;\n        this.discoveryDocumentLoadedSubject.next(doc);\n        this.revocationEndpoint = doc.revocation_endpoint || this.revocationEndpoint;\n\n        if (this.sessionChecksEnabled) {\n          this.restartSessionChecksIfStillLoggedIn();\n        }\n\n        this.loadJwks().then(jwks => {\n          const result = {\n            discoveryDocument: doc,\n            jwks: jwks\n          };\n          const event = new OAuthSuccessEvent('discovery_document_loaded', result);\n          this.eventsSubject.next(event);\n          resolve(event);\n          return;\n        }).catch(err => {\n          this.eventsSubject.next(new OAuthErrorEvent('discovery_document_load_error', err));\n          reject(err);\n          return;\n        });\n      }, err => {\n        this.logger.error('error loading discovery document', err);\n        this.eventsSubject.next(new OAuthErrorEvent('discovery_document_load_error', err));\n        reject(err);\n      });\n    });\n  }\n\n  loadJwks() {\n    return new Promise((resolve, reject) => {\n      if (this.jwksUri) {\n        this.http.get(this.jwksUri).subscribe(jwks => {\n          this.jwks = jwks; // this.eventsSubject.next(\n          //   new OAuthSuccessEvent('discovery_document_loaded')\n          // );\n\n          resolve(jwks);\n        }, err => {\n          this.logger.error('error loading jwks', err);\n          this.eventsSubject.next(new OAuthErrorEvent('jwks_load_error', err));\n          reject(err);\n        });\n      } else {\n        resolve(null);\n      }\n    });\n  }\n\n  validateDiscoveryDocument(doc) {\n    let errors;\n\n    if (!this.skipIssuerCheck && doc.issuer !== this.issuer) {\n      this.logger.error('invalid issuer in discovery document', 'expected: ' + this.issuer, 'current: ' + doc.issuer);\n      return false;\n    }\n\n    errors = this.validateUrlFromDiscoveryDocument(doc.authorization_endpoint);\n\n    if (errors.length > 0) {\n      this.logger.error('error validating authorization_endpoint in discovery document', errors);\n      return false;\n    }\n\n    errors = this.validateUrlFromDiscoveryDocument(doc.end_session_endpoint);\n\n    if (errors.length > 0) {\n      this.logger.error('error validating end_session_endpoint in discovery document', errors);\n      return false;\n    }\n\n    errors = this.validateUrlFromDiscoveryDocument(doc.token_endpoint);\n\n    if (errors.length > 0) {\n      this.logger.error('error validating token_endpoint in discovery document', errors);\n    }\n\n    errors = this.validateUrlFromDiscoveryDocument(doc.revocation_endpoint);\n\n    if (errors.length > 0) {\n      this.logger.error('error validating revocation_endpoint in discovery document', errors);\n    }\n\n    errors = this.validateUrlFromDiscoveryDocument(doc.userinfo_endpoint);\n\n    if (errors.length > 0) {\n      this.logger.error('error validating userinfo_endpoint in discovery document', errors);\n      return false;\n    }\n\n    errors = this.validateUrlFromDiscoveryDocument(doc.jwks_uri);\n\n    if (errors.length > 0) {\n      this.logger.error('error validating jwks_uri in discovery document', errors);\n      return false;\n    }\n\n    if (this.sessionChecksEnabled && !doc.check_session_iframe) {\n      this.logger.warn('sessionChecksEnabled is activated but discovery document' + ' does not contain a check_session_iframe field');\n    }\n\n    return true;\n  }\n  /**\r\n   * Uses password flow to exchange userName and password for an\r\n   * access_token. After receiving the access_token, this method\r\n   * uses it to query the userinfo endpoint in order to get information\r\n   * about the user in question.\r\n   *\r\n   * When using this, make sure that the property oidc is set to false.\r\n   * Otherwise stricter validations take place that make this operation\r\n   * fail.\r\n   *\r\n   * @param userName\r\n   * @param password\r\n   * @param headers Optional additional http-headers.\r\n   */\n\n\n  fetchTokenUsingPasswordFlowAndLoadUserProfile(userName, password, headers = new HttpHeaders()) {\n    return this.fetchTokenUsingPasswordFlow(userName, password, headers).then(() => this.loadUserProfile());\n  }\n  /**\r\n   * Loads the user profile by accessing the user info endpoint defined by OpenId Connect.\r\n   *\r\n   * When using this with OAuth2 password flow, make sure that the property oidc is set to false.\r\n   * Otherwise stricter validations take place that make this operation fail.\r\n   */\n\n\n  loadUserProfile() {\n    if (!this.hasValidAccessToken()) {\n      throw new Error('Can not load User Profile without access_token');\n    }\n\n    if (!this.validateUrlForHttps(this.userinfoEndpoint)) {\n      throw new Error(\"userinfoEndpoint must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\");\n    }\n\n    return new Promise((resolve, reject) => {\n      const headers = new HttpHeaders().set('Authorization', 'Bearer ' + this.getAccessToken());\n      this.http.get(this.userinfoEndpoint, {\n        headers,\n        observe: 'response',\n        responseType: 'text'\n      }).subscribe(response => {\n        this.debug('userinfo received', JSON.stringify(response));\n\n        if (response.headers.get('content-type').startsWith('application/json')) {\n          let info = JSON.parse(response.body);\n          const existingClaims = this.getIdentityClaims() || {};\n\n          if (!this.skipSubjectCheck) {\n            if (this.oidc && (!existingClaims['sub'] || info.sub !== existingClaims['sub'])) {\n              const err = 'if property oidc is true, the received user-id (sub) has to be the user-id ' + 'of the user that has logged in with oidc.\\n' + 'if you are not using oidc but just oauth2 password flow set oidc to false';\n              reject(err);\n              return;\n            }\n          }\n\n          info = Object.assign({}, existingClaims, info);\n\n          this._storage.setItem('id_token_claims_obj', JSON.stringify(info));\n\n          this.eventsSubject.next(new OAuthSuccessEvent('user_profile_loaded'));\n          resolve({\n            info\n          });\n        } else {\n          this.debug('userinfo is not JSON, treating it as JWE/JWS');\n          this.eventsSubject.next(new OAuthSuccessEvent('user_profile_loaded'));\n          resolve(JSON.parse(response.body));\n        }\n      }, err => {\n        this.logger.error('error loading user info', err);\n        this.eventsSubject.next(new OAuthErrorEvent('user_profile_load_error', err));\n        reject(err);\n      });\n    });\n  }\n  /**\r\n   * Uses password flow to exchange userName and password for an access_token.\r\n   * @param userName\r\n   * @param password\r\n   * @param headers Optional additional http-headers.\r\n   */\n\n\n  fetchTokenUsingPasswordFlow(userName, password, headers = new HttpHeaders()) {\n    const parameters = {\n      username: userName,\n      password: password\n    };\n    return this.fetchTokenUsingGrant('password', parameters, headers);\n  }\n  /**\r\n   * Uses a custom grant type to retrieve tokens.\r\n   * @param grantType Grant type.\r\n   * @param parameters Parameters to pass.\r\n   * @param headers Optional additional HTTP headers.\r\n   */\n\n\n  fetchTokenUsingGrant(grantType, parameters, headers = new HttpHeaders()) {\n    this.assertUrlNotNullAndCorrectProtocol(this.tokenEndpoint, 'tokenEndpoint');\n    /**\r\n     * A `HttpParameterCodec` that uses `encodeURIComponent` and `decodeURIComponent` to\r\n     * serialize and parse URL parameter keys and values.\r\n     *\r\n     * @stable\r\n     */\n\n    let params = new HttpParams({\n      encoder: new WebHttpUrlEncodingCodec()\n    }).set('grant_type', grantType).set('scope', this.scope);\n\n    if (this.useHttpBasicAuth) {\n      const header = btoa(`${this.clientId}:${this.dummyClientSecret}`);\n      headers = headers.set('Authorization', 'Basic ' + header);\n    }\n\n    if (!this.useHttpBasicAuth) {\n      params = params.set('client_id', this.clientId);\n    }\n\n    if (!this.useHttpBasicAuth && this.dummyClientSecret) {\n      params = params.set('client_secret', this.dummyClientSecret);\n    }\n\n    if (this.customQueryParams) {\n      for (const key of Object.getOwnPropertyNames(this.customQueryParams)) {\n        params = params.set(key, this.customQueryParams[key]);\n      }\n    } // set explicit parameters last, to allow overwriting\n\n\n    for (const key of Object.keys(parameters)) {\n      params = params.set(key, parameters[key]);\n    }\n\n    headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\n    return new Promise((resolve, reject) => {\n      this.http.post(this.tokenEndpoint, params, {\n        headers\n      }).subscribe(tokenResponse => {\n        this.debug('tokenResponse', tokenResponse);\n        this.storeAccessTokenResponse(tokenResponse.access_token, tokenResponse.refresh_token, tokenResponse.expires_in || this.fallbackAccessTokenExpirationTimeInSec, tokenResponse.scope, this.extractRecognizedCustomParameters(tokenResponse));\n\n        if (this.oidc && tokenResponse.id_token) {\n          this.processIdToken(tokenResponse.id_token, tokenResponse.access_token).then(result => {\n            this.storeIdToken(result);\n            resolve(tokenResponse);\n          });\n        }\n\n        this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n        resolve(tokenResponse);\n      }, err => {\n        this.logger.error('Error performing ${grantType} flow', err);\n        this.eventsSubject.next(new OAuthErrorEvent('token_error', err));\n        reject(err);\n      });\n    });\n  }\n  /**\r\n   * Refreshes the token using a refresh_token.\r\n   * This does not work for implicit flow, b/c\r\n   * there is no refresh_token in this flow.\r\n   * A solution for this is provided by the\r\n   * method silentRefresh.\r\n   */\n\n\n  refreshToken() {\n    this.assertUrlNotNullAndCorrectProtocol(this.tokenEndpoint, 'tokenEndpoint');\n    return new Promise((resolve, reject) => {\n      let params = new HttpParams({\n        encoder: new WebHttpUrlEncodingCodec()\n      }).set('grant_type', 'refresh_token').set('scope', this.scope).set('refresh_token', this._storage.getItem('refresh_token'));\n      let headers = new HttpHeaders().set('Content-Type', 'application/x-www-form-urlencoded');\n\n      if (this.useHttpBasicAuth) {\n        const header = btoa(`${this.clientId}:${this.dummyClientSecret}`);\n        headers = headers.set('Authorization', 'Basic ' + header);\n      }\n\n      if (!this.useHttpBasicAuth) {\n        params = params.set('client_id', this.clientId);\n      }\n\n      if (!this.useHttpBasicAuth && this.dummyClientSecret) {\n        params = params.set('client_secret', this.dummyClientSecret);\n      }\n\n      if (this.customQueryParams) {\n        for (const key of Object.getOwnPropertyNames(this.customQueryParams)) {\n          params = params.set(key, this.customQueryParams[key]);\n        }\n      }\n\n      this.http.post(this.tokenEndpoint, params, {\n        headers\n      }).pipe(switchMap(tokenResponse => {\n        if (this.oidc && tokenResponse.id_token) {\n          return from(this.processIdToken(tokenResponse.id_token, tokenResponse.access_token, true)).pipe(tap(result => this.storeIdToken(result)), map(_ => tokenResponse));\n        } else {\n          return of(tokenResponse);\n        }\n      })).subscribe(tokenResponse => {\n        this.debug('refresh tokenResponse', tokenResponse);\n        this.storeAccessTokenResponse(tokenResponse.access_token, tokenResponse.refresh_token, tokenResponse.expires_in || this.fallbackAccessTokenExpirationTimeInSec, tokenResponse.scope, this.extractRecognizedCustomParameters(tokenResponse));\n        this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n        this.eventsSubject.next(new OAuthSuccessEvent('token_refreshed'));\n        resolve(tokenResponse);\n      }, err => {\n        this.logger.error('Error refreshing token', err);\n        this.eventsSubject.next(new OAuthErrorEvent('token_refresh_error', err));\n        reject(err);\n      });\n    });\n  }\n\n  removeSilentRefreshEventListener() {\n    if (this.silentRefreshPostMessageEventListener) {\n      window.removeEventListener('message', this.silentRefreshPostMessageEventListener);\n      this.silentRefreshPostMessageEventListener = null;\n    }\n  }\n\n  setupSilentRefreshEventListener() {\n    this.removeSilentRefreshEventListener();\n\n    this.silentRefreshPostMessageEventListener = e => {\n      const message = this.processMessageEventMessage(e);\n\n      if (this.checkOrigin && e.origin !== location.origin) {\n        console.error('wrong origin requested silent refresh!');\n      }\n\n      this.tryLogin({\n        customHashFragment: message,\n        preventClearHashAfterLogin: true,\n        customRedirectUri: this.silentRefreshRedirectUri || this.redirectUri\n      }).catch(err => this.debug('tryLogin during silent refresh failed', err));\n    };\n\n    window.addEventListener('message', this.silentRefreshPostMessageEventListener);\n  }\n  /**\r\n   * Performs a silent refresh for implicit flow.\r\n   * Use this method to get new tokens when/before\r\n   * the existing tokens expire.\r\n   */\n\n\n  silentRefresh(params = {}, noPrompt = true) {\n    const claims = this.getIdentityClaims() || {};\n\n    if (this.useIdTokenHintForSilentRefresh && this.hasValidIdToken()) {\n      params['id_token_hint'] = this.getIdToken();\n    }\n\n    if (!this.validateUrlForHttps(this.loginUrl)) {\n      throw new Error(\"loginUrl  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\");\n    }\n\n    if (typeof this.document === 'undefined') {\n      throw new Error('silent refresh is not supported on this platform');\n    }\n\n    const existingIframe = this.document.getElementById(this.silentRefreshIFrameName);\n\n    if (existingIframe) {\n      this.document.body.removeChild(existingIframe);\n    }\n\n    this.silentRefreshSubject = claims['sub'];\n    const iframe = this.document.createElement('iframe');\n    iframe.id = this.silentRefreshIFrameName;\n    this.setupSilentRefreshEventListener();\n    const redirectUri = this.silentRefreshRedirectUri || this.redirectUri;\n    this.createLoginUrl(null, null, redirectUri, noPrompt, params).then(url => {\n      iframe.setAttribute('src', url);\n\n      if (!this.silentRefreshShowIFrame) {\n        iframe.style['display'] = 'none';\n      }\n\n      this.document.body.appendChild(iframe);\n    });\n    const errors = this.events.pipe(filter(e => e instanceof OAuthErrorEvent), first());\n    const success = this.events.pipe(filter(e => e.type === 'token_received'), first());\n    const timeout = of(new OAuthErrorEvent('silent_refresh_timeout', null)).pipe(delay(this.silentRefreshTimeout));\n    return race([errors, success, timeout]).pipe(map(e => {\n      if (e instanceof OAuthErrorEvent) {\n        if (e.type === 'silent_refresh_timeout') {\n          this.eventsSubject.next(e);\n        } else {\n          e = new OAuthErrorEvent('silent_refresh_error', e);\n          this.eventsSubject.next(e);\n        }\n\n        throw e;\n      } else if (e.type === 'token_received') {\n        e = new OAuthSuccessEvent('silently_refreshed');\n        this.eventsSubject.next(e);\n      }\n\n      return e;\n    })).toPromise();\n  }\n  /**\r\n   * This method exists for backwards compatibility.\r\n   * {@link OAuthService#initLoginFlowInPopup} handles both code\r\n   * and implicit flows.\r\n   */\n\n\n  initImplicitFlowInPopup(options) {\n    return this.initLoginFlowInPopup(options);\n  }\n\n  initLoginFlowInPopup(options) {\n    options = options || {};\n    return this.createLoginUrl(null, null, this.silentRefreshRedirectUri, false, {\n      display: 'popup'\n    }).then(url => {\n      return new Promise((resolve, reject) => {\n        /**\r\n         * Error handling section\r\n         */\n        const checkForPopupClosedInterval = 500;\n        let windowRef = null; // If we got no window reference we open a window\n        // else we are using the window already opened\n\n        if (!options.windowRef) {\n          windowRef = window.open(url, 'ngx-oauth2-oidc-login', this.calculatePopupFeatures(options));\n        } else if (options.windowRef && !options.windowRef.closed) {\n          windowRef = options.windowRef;\n          windowRef.location.href = url;\n        }\n\n        let checkForPopupClosedTimer;\n\n        const tryLogin = hash => {\n          this.tryLogin({\n            customHashFragment: hash,\n            preventClearHashAfterLogin: true,\n            customRedirectUri: this.silentRefreshRedirectUri\n          }).then(() => {\n            cleanup();\n            resolve(true);\n          }, err => {\n            cleanup();\n            reject(err);\n          });\n        };\n\n        const checkForPopupClosed = () => {\n          if (!windowRef || windowRef.closed) {\n            cleanup();\n            reject(new OAuthErrorEvent('popup_closed', {}));\n          }\n        };\n\n        if (!windowRef) {\n          reject(new OAuthErrorEvent('popup_blocked', {}));\n        } else {\n          checkForPopupClosedTimer = window.setInterval(checkForPopupClosed, checkForPopupClosedInterval);\n        }\n\n        const cleanup = () => {\n          window.clearInterval(checkForPopupClosedTimer);\n          window.removeEventListener('storage', storageListener);\n          window.removeEventListener('message', listener);\n\n          if (windowRef !== null) {\n            windowRef.close();\n          }\n\n          windowRef = null;\n        };\n\n        const listener = e => {\n          const message = this.processMessageEventMessage(e);\n\n          if (message && message !== null) {\n            window.removeEventListener('storage', storageListener);\n            tryLogin(message);\n          } else {\n            console.log('false event firing');\n          }\n        };\n\n        const storageListener = event => {\n          if (event.key === 'auth_hash') {\n            window.removeEventListener('message', listener);\n            tryLogin(event.newValue);\n          }\n        };\n\n        window.addEventListener('message', listener);\n        window.addEventListener('storage', storageListener);\n      });\n    });\n  }\n\n  calculatePopupFeatures(options) {\n    // Specify an static height and width and calculate centered position\n    const height = options.height || 470;\n    const width = options.width || 500;\n    const left = window.screenLeft + (window.outerWidth - width) / 2;\n    const top = window.screenTop + (window.outerHeight - height) / 2;\n    return `location=no,toolbar=no,width=${width},height=${height},top=${top},left=${left}`;\n  }\n\n  processMessageEventMessage(e) {\n    let expectedPrefix = '#';\n\n    if (this.silentRefreshMessagePrefix) {\n      expectedPrefix += this.silentRefreshMessagePrefix;\n    }\n\n    if (!e || !e.data || typeof e.data !== 'string') {\n      return;\n    }\n\n    const prefixedMessage = e.data;\n\n    if (!prefixedMessage.startsWith(expectedPrefix)) {\n      return;\n    }\n\n    return '#' + prefixedMessage.substr(expectedPrefix.length);\n  }\n\n  canPerformSessionCheck() {\n    if (!this.sessionChecksEnabled) {\n      return false;\n    }\n\n    if (!this.sessionCheckIFrameUrl) {\n      console.warn('sessionChecksEnabled is activated but there is no sessionCheckIFrameUrl');\n      return false;\n    }\n\n    const sessionState = this.getSessionState();\n\n    if (!sessionState) {\n      console.warn('sessionChecksEnabled is activated but there is no session_state');\n      return false;\n    }\n\n    if (typeof this.document === 'undefined') {\n      return false;\n    }\n\n    return true;\n  }\n\n  setupSessionCheckEventListener() {\n    this.removeSessionCheckEventListener();\n\n    this.sessionCheckEventListener = e => {\n      const origin = e.origin.toLowerCase();\n      const issuer = this.issuer.toLowerCase();\n      this.debug('sessionCheckEventListener');\n\n      if (!issuer.startsWith(origin)) {\n        this.debug('sessionCheckEventListener', 'wrong origin', origin, 'expected', issuer, 'event', e);\n        return;\n      } // only run in Angular zone if it is 'changed' or 'error'\n\n\n      switch (e.data) {\n        case 'unchanged':\n          this.ngZone.run(() => {\n            this.handleSessionUnchanged();\n          });\n          break;\n\n        case 'changed':\n          this.ngZone.run(() => {\n            this.handleSessionChange();\n          });\n          break;\n\n        case 'error':\n          this.ngZone.run(() => {\n            this.handleSessionError();\n          });\n          break;\n      }\n\n      this.debug('got info from session check inframe', e);\n    }; // prevent Angular from refreshing the view on every message (runs in intervals)\n\n\n    this.ngZone.runOutsideAngular(() => {\n      window.addEventListener('message', this.sessionCheckEventListener);\n    });\n  }\n\n  handleSessionUnchanged() {\n    this.debug('session check', 'session unchanged');\n    this.eventsSubject.next(new OAuthInfoEvent('session_unchanged'));\n  }\n\n  handleSessionChange() {\n    this.eventsSubject.next(new OAuthInfoEvent('session_changed'));\n    this.stopSessionCheckTimer();\n\n    if (!this.useSilentRefresh && this.responseType === 'code') {\n      this.refreshToken().then(_ => {\n        this.debug('token refresh after session change worked');\n      }).catch(_ => {\n        this.debug('token refresh did not work after session changed');\n        this.eventsSubject.next(new OAuthInfoEvent('session_terminated'));\n        this.logOut(true);\n      });\n    } else if (this.silentRefreshRedirectUri) {\n      this.silentRefresh().catch(_ => this.debug('silent refresh failed after session changed'));\n      this.waitForSilentRefreshAfterSessionChange();\n    } else {\n      this.eventsSubject.next(new OAuthInfoEvent('session_terminated'));\n      this.logOut(true);\n    }\n  }\n\n  waitForSilentRefreshAfterSessionChange() {\n    this.events.pipe(filter(e => e.type === 'silently_refreshed' || e.type === 'silent_refresh_timeout' || e.type === 'silent_refresh_error'), first()).subscribe(e => {\n      if (e.type !== 'silently_refreshed') {\n        this.debug('silent refresh did not work after session changed');\n        this.eventsSubject.next(new OAuthInfoEvent('session_terminated'));\n        this.logOut(true);\n      }\n    });\n  }\n\n  handleSessionError() {\n    this.stopSessionCheckTimer();\n    this.eventsSubject.next(new OAuthInfoEvent('session_error'));\n  }\n\n  removeSessionCheckEventListener() {\n    if (this.sessionCheckEventListener) {\n      window.removeEventListener('message', this.sessionCheckEventListener);\n      this.sessionCheckEventListener = null;\n    }\n  }\n\n  initSessionCheck() {\n    if (!this.canPerformSessionCheck()) {\n      return;\n    }\n\n    const existingIframe = this.document.getElementById(this.sessionCheckIFrameName);\n\n    if (existingIframe) {\n      this.document.body.removeChild(existingIframe);\n    }\n\n    const iframe = this.document.createElement('iframe');\n    iframe.id = this.sessionCheckIFrameName;\n    this.setupSessionCheckEventListener();\n    const url = this.sessionCheckIFrameUrl;\n    iframe.setAttribute('src', url);\n    iframe.style.display = 'none';\n    this.document.body.appendChild(iframe);\n    this.startSessionCheckTimer();\n  }\n\n  startSessionCheckTimer() {\n    this.stopSessionCheckTimer();\n    this.ngZone.runOutsideAngular(() => {\n      this.sessionCheckTimer = setInterval(this.checkSession.bind(this), this.sessionCheckIntervall);\n    });\n  }\n\n  stopSessionCheckTimer() {\n    if (this.sessionCheckTimer) {\n      clearInterval(this.sessionCheckTimer);\n      this.sessionCheckTimer = null;\n    }\n  }\n\n  checkSession() {\n    const iframe = this.document.getElementById(this.sessionCheckIFrameName);\n\n    if (!iframe) {\n      this.logger.warn('checkSession did not find iframe', this.sessionCheckIFrameName);\n    }\n\n    const sessionState = this.getSessionState();\n\n    if (!sessionState) {\n      this.stopSessionCheckTimer();\n    }\n\n    const message = this.clientId + ' ' + sessionState;\n    iframe.contentWindow.postMessage(message, this.issuer);\n  }\n\n  createLoginUrl(state = '', loginHint = '', customRedirectUri = '', noPrompt = false, params = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const that = this;\n      let redirectUri;\n\n      if (customRedirectUri) {\n        redirectUri = customRedirectUri;\n      } else {\n        redirectUri = this.redirectUri;\n      }\n\n      const nonce = yield this.createAndSaveNonce();\n\n      if (state) {\n        state = nonce + this.config.nonceStateSeparator + encodeURIComponent(state);\n      } else {\n        state = nonce;\n      }\n\n      if (!this.requestAccessToken && !this.oidc) {\n        throw new Error('Either requestAccessToken or oidc or both must be true');\n      }\n\n      if (this.config.responseType) {\n        this.responseType = this.config.responseType;\n      } else {\n        if (this.oidc && this.requestAccessToken) {\n          this.responseType = 'id_token token';\n        } else if (this.oidc && !this.requestAccessToken) {\n          this.responseType = 'id_token';\n        } else {\n          this.responseType = 'token';\n        }\n      }\n\n      const seperationChar = that.loginUrl.indexOf('?') > -1 ? '&' : '?';\n      let scope = that.scope;\n\n      if (this.oidc && !scope.match(/(^|\\s)openid($|\\s)/)) {\n        scope = 'openid ' + scope;\n      }\n\n      let url = that.loginUrl + seperationChar + 'response_type=' + encodeURIComponent(that.responseType) + '&client_id=' + encodeURIComponent(that.clientId) + '&state=' + encodeURIComponent(state) + '&redirect_uri=' + encodeURIComponent(redirectUri) + '&scope=' + encodeURIComponent(scope);\n\n      if (this.responseType.includes('code') && !this.disablePKCE) {\n        const [challenge, verifier] = yield this.createChallangeVerifierPairForPKCE();\n\n        if (this.saveNoncesInLocalStorage && typeof window['localStorage'] !== 'undefined') {\n          localStorage.setItem('PKCE_verifier', verifier);\n        } else {\n          this._storage.setItem('PKCE_verifier', verifier);\n        }\n\n        url += '&code_challenge=' + challenge;\n        url += '&code_challenge_method=S256';\n      }\n\n      if (loginHint) {\n        url += '&login_hint=' + encodeURIComponent(loginHint);\n      }\n\n      if (that.resource) {\n        url += '&resource=' + encodeURIComponent(that.resource);\n      }\n\n      if (that.oidc) {\n        url += '&nonce=' + encodeURIComponent(nonce);\n      }\n\n      if (noPrompt) {\n        url += '&prompt=none';\n      }\n\n      for (const key of Object.keys(params)) {\n        url += '&' + encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);\n      }\n\n      if (this.customQueryParams) {\n        for (const key of Object.getOwnPropertyNames(this.customQueryParams)) {\n          url += '&' + key + '=' + encodeURIComponent(this.customQueryParams[key]);\n        }\n      }\n\n      return url;\n    });\n  }\n\n  initImplicitFlowInternal(additionalState = '', params = '') {\n    if (this.inImplicitFlow) {\n      return;\n    }\n\n    this.inImplicitFlow = true;\n\n    if (!this.validateUrlForHttps(this.loginUrl)) {\n      throw new Error(\"loginUrl  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\");\n    }\n\n    let addParams = {};\n    let loginHint = null;\n\n    if (typeof params === 'string') {\n      loginHint = params;\n    } else if (typeof params === 'object') {\n      addParams = params;\n    }\n\n    this.createLoginUrl(additionalState, loginHint, null, false, addParams).then(this.config.openUri).catch(error => {\n      console.error('Error in initImplicitFlow', error);\n      this.inImplicitFlow = false;\n    });\n  }\n  /**\r\n   * Starts the implicit flow and redirects to user to\r\n   * the auth servers' login url.\r\n   *\r\n   * @param additionalState Optional state that is passed around.\r\n   *  You'll find this state in the property `state` after `tryLogin` logged in the user.\r\n   * @param params Hash with additional parameter. If it is a string, it is used for the\r\n   *               parameter loginHint (for the sake of compatibility with former versions)\r\n   */\n\n\n  initImplicitFlow(additionalState = '', params = '') {\n    if (this.loginUrl !== '') {\n      this.initImplicitFlowInternal(additionalState, params);\n    } else {\n      this.events.pipe(filter(e => e.type === 'discovery_document_loaded')).subscribe(_ => this.initImplicitFlowInternal(additionalState, params));\n    }\n  }\n  /**\r\n   * Reset current implicit flow\r\n   *\r\n   * @description This method allows resetting the current implict flow in order to be initialized again.\r\n   */\n\n\n  resetImplicitFlow() {\n    this.inImplicitFlow = false;\n  }\n\n  callOnTokenReceivedIfExists(options) {\n    const that = this;\n\n    if (options.onTokenReceived) {\n      const tokenParams = {\n        idClaims: that.getIdentityClaims(),\n        idToken: that.getIdToken(),\n        accessToken: that.getAccessToken(),\n        state: that.state\n      };\n      options.onTokenReceived(tokenParams);\n    }\n  }\n\n  storeAccessTokenResponse(accessToken, refreshToken, expiresIn, grantedScopes, customParameters) {\n    this._storage.setItem('access_token', accessToken);\n\n    if (grantedScopes && !Array.isArray(grantedScopes)) {\n      this._storage.setItem('granted_scopes', JSON.stringify(grantedScopes.split(' ')));\n    } else if (grantedScopes && Array.isArray(grantedScopes)) {\n      this._storage.setItem('granted_scopes', JSON.stringify(grantedScopes));\n    }\n\n    this._storage.setItem('access_token_stored_at', '' + this.dateTimeService.now());\n\n    if (expiresIn) {\n      const expiresInMilliSeconds = expiresIn * 1000;\n      const now = this.dateTimeService.new();\n      const expiresAt = now.getTime() + expiresInMilliSeconds;\n\n      this._storage.setItem('expires_at', '' + expiresAt);\n    }\n\n    if (refreshToken) {\n      this._storage.setItem('refresh_token', refreshToken);\n    }\n\n    if (customParameters) {\n      customParameters.forEach((value, key) => {\n        this._storage.setItem(key, value);\n      });\n    }\n  }\n  /**\r\n   * Delegates to tryLoginImplicitFlow for the sake of competability\r\n   * @param options Optional options.\r\n   */\n\n\n  tryLogin(options = null) {\n    if (this.config.responseType === 'code') {\n      return this.tryLoginCodeFlow(options).then(_ => true);\n    } else {\n      return this.tryLoginImplicitFlow(options);\n    }\n  }\n\n  parseQueryString(queryString) {\n    if (!queryString || queryString.length === 0) {\n      return {};\n    }\n\n    if (queryString.charAt(0) === '?') {\n      queryString = queryString.substr(1);\n    }\n\n    return this.urlHelper.parseQueryString(queryString);\n  }\n\n  tryLoginCodeFlow(options = null) {\n    return __awaiter(this, void 0, void 0, function* () {\n      options = options || {};\n      const querySource = options.customHashFragment ? options.customHashFragment.substring(1) : window.location.search;\n      const parts = this.getCodePartsFromUrl(querySource);\n      const code = parts['code'];\n      const state = parts['state'];\n      const sessionState = parts['session_state'];\n\n      if (!options.preventClearHashAfterLogin) {\n        const href = location.origin + location.pathname + location.search.replace(/code=[^&\\$]*/, '').replace(/scope=[^&\\$]*/, '').replace(/state=[^&\\$]*/, '').replace(/session_state=[^&\\$]*/, '').replace(/^\\?&/, '?').replace(/&$/, '').replace(/^\\?$/, '').replace(/&+/g, '&').replace(/\\?&/, '?').replace(/\\?$/, '') + location.hash;\n        history.replaceState(null, window.name, href);\n      }\n\n      let [nonceInState, userState] = this.parseState(state);\n      this.state = userState;\n\n      if (parts['error']) {\n        this.debug('error trying to login');\n        this.handleLoginError(options, parts);\n        const err = new OAuthErrorEvent('code_error', {}, parts);\n        this.eventsSubject.next(err);\n        return Promise.reject(err);\n      }\n\n      if (!options.disableNonceCheck) {\n        if (!nonceInState) {\n          this.saveRequestedRoute();\n          return Promise.resolve();\n        }\n\n        if (!options.disableOAuth2StateCheck) {\n          const success = this.validateNonce(nonceInState);\n\n          if (!success) {\n            const event = new OAuthErrorEvent('invalid_nonce_in_state', null);\n            this.eventsSubject.next(event);\n            return Promise.reject(event);\n          }\n        }\n      }\n\n      this.storeSessionState(sessionState);\n\n      if (code) {\n        yield this.getTokenFromCode(code, options);\n        this.restoreRequestedRoute();\n        return Promise.resolve();\n      } else {\n        return Promise.resolve();\n      }\n    });\n  }\n\n  saveRequestedRoute() {\n    if (this.config.preserveRequestedRoute) {\n      this._storage.setItem('requested_route', window.location.pathname + window.location.search);\n    }\n  }\n\n  restoreRequestedRoute() {\n    const requestedRoute = this._storage.getItem('requested_route');\n\n    if (requestedRoute) {\n      history.replaceState(null, '', window.location.origin + requestedRoute);\n    }\n  }\n  /**\r\n   * Retrieve the returned auth code from the redirect uri that has been called.\r\n   * If required also check hash, as we could use hash location strategy.\r\n   */\n\n\n  getCodePartsFromUrl(queryString) {\n    if (!queryString || queryString.length === 0) {\n      return this.urlHelper.getHashFragmentParams();\n    } // normalize query string\n\n\n    if (queryString.charAt(0) === '?') {\n      queryString = queryString.substr(1);\n    }\n\n    return this.urlHelper.parseQueryString(queryString);\n  }\n  /**\r\n   * Get token using an intermediate code. Works for the Authorization Code flow.\r\n   */\n\n\n  getTokenFromCode(code, options) {\n    let params = new HttpParams({\n      encoder: new WebHttpUrlEncodingCodec()\n    }).set('grant_type', 'authorization_code').set('code', code).set('redirect_uri', options.customRedirectUri || this.redirectUri);\n\n    if (!this.disablePKCE) {\n      let PKCEVerifier;\n\n      if (this.saveNoncesInLocalStorage && typeof window['localStorage'] !== 'undefined') {\n        PKCEVerifier = localStorage.getItem('PKCE_verifier');\n      } else {\n        PKCEVerifier = this._storage.getItem('PKCE_verifier');\n      }\n\n      if (!PKCEVerifier) {\n        console.warn('No PKCE verifier found in oauth storage!');\n      } else {\n        params = params.set('code_verifier', PKCEVerifier);\n      }\n    }\n\n    return this.fetchAndProcessToken(params, options);\n  }\n\n  fetchAndProcessToken(params, options) {\n    options = options || {};\n    this.assertUrlNotNullAndCorrectProtocol(this.tokenEndpoint, 'tokenEndpoint');\n    let headers = new HttpHeaders().set('Content-Type', 'application/x-www-form-urlencoded');\n\n    if (this.useHttpBasicAuth) {\n      const header = btoa(`${this.clientId}:${this.dummyClientSecret}`);\n      headers = headers.set('Authorization', 'Basic ' + header);\n    }\n\n    if (!this.useHttpBasicAuth) {\n      params = params.set('client_id', this.clientId);\n    }\n\n    if (!this.useHttpBasicAuth && this.dummyClientSecret) {\n      params = params.set('client_secret', this.dummyClientSecret);\n    }\n\n    return new Promise((resolve, reject) => {\n      if (this.customQueryParams) {\n        for (let key of Object.getOwnPropertyNames(this.customQueryParams)) {\n          params = params.set(key, this.customQueryParams[key]);\n        }\n      }\n\n      this.http.post(this.tokenEndpoint, params, {\n        headers\n      }).subscribe(tokenResponse => {\n        this.debug('refresh tokenResponse', tokenResponse);\n        this.storeAccessTokenResponse(tokenResponse.access_token, tokenResponse.refresh_token, tokenResponse.expires_in || this.fallbackAccessTokenExpirationTimeInSec, tokenResponse.scope, this.extractRecognizedCustomParameters(tokenResponse));\n\n        if (this.oidc && tokenResponse.id_token) {\n          this.processIdToken(tokenResponse.id_token, tokenResponse.access_token, options.disableNonceCheck).then(result => {\n            this.storeIdToken(result);\n            this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n            this.eventsSubject.next(new OAuthSuccessEvent('token_refreshed'));\n            resolve(tokenResponse);\n          }).catch(reason => {\n            this.eventsSubject.next(new OAuthErrorEvent('token_validation_error', reason));\n            console.error('Error validating tokens');\n            console.error(reason);\n            reject(reason);\n          });\n        } else {\n          this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n          this.eventsSubject.next(new OAuthSuccessEvent('token_refreshed'));\n          resolve(tokenResponse);\n        }\n      }, err => {\n        console.error('Error getting token', err);\n        this.eventsSubject.next(new OAuthErrorEvent('token_refresh_error', err));\n        reject(err);\n      });\n    });\n  }\n  /**\r\n   * Checks whether there are tokens in the hash fragment\r\n   * as a result of the implicit flow. These tokens are\r\n   * parsed, validated and used to sign the user in to the\r\n   * current client.\r\n   *\r\n   * @param options Optional options.\r\n   */\n\n\n  tryLoginImplicitFlow(options = null) {\n    options = options || {};\n    let parts;\n\n    if (options.customHashFragment) {\n      parts = this.urlHelper.getHashFragmentParams(options.customHashFragment);\n    } else {\n      parts = this.urlHelper.getHashFragmentParams();\n    }\n\n    this.debug('parsed url', parts);\n    const state = parts['state'];\n    let [nonceInState, userState] = this.parseState(state);\n    this.state = userState;\n\n    if (parts['error']) {\n      this.debug('error trying to login');\n      this.handleLoginError(options, parts);\n      const err = new OAuthErrorEvent('token_error', {}, parts);\n      this.eventsSubject.next(err);\n      return Promise.reject(err);\n    }\n\n    const accessToken = parts['access_token'];\n    const idToken = parts['id_token'];\n    const sessionState = parts['session_state'];\n    const grantedScopes = parts['scope'];\n\n    if (!this.requestAccessToken && !this.oidc) {\n      return Promise.reject('Either requestAccessToken or oidc (or both) must be true.');\n    }\n\n    if (this.requestAccessToken && !accessToken) {\n      return Promise.resolve(false);\n    }\n\n    if (this.requestAccessToken && !options.disableOAuth2StateCheck && !state) {\n      return Promise.resolve(false);\n    }\n\n    if (this.oidc && !idToken) {\n      return Promise.resolve(false);\n    }\n\n    if (this.sessionChecksEnabled && !sessionState) {\n      this.logger.warn('session checks (Session Status Change Notification) ' + 'were activated in the configuration but the id_token ' + 'does not contain a session_state claim');\n    }\n\n    if (this.requestAccessToken && !options.disableNonceCheck) {\n      const success = this.validateNonce(nonceInState);\n\n      if (!success) {\n        const event = new OAuthErrorEvent('invalid_nonce_in_state', null);\n        this.eventsSubject.next(event);\n        return Promise.reject(event);\n      }\n    }\n\n    if (this.requestAccessToken) {\n      this.storeAccessTokenResponse(accessToken, null, parts['expires_in'] || this.fallbackAccessTokenExpirationTimeInSec, grantedScopes);\n    }\n\n    if (!this.oidc) {\n      this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n\n      if (this.clearHashAfterLogin && !options.preventClearHashAfterLogin) {\n        this.clearLocationHash();\n      }\n\n      this.callOnTokenReceivedIfExists(options);\n      return Promise.resolve(true);\n    }\n\n    return this.processIdToken(idToken, accessToken, options.disableNonceCheck).then(result => {\n      if (options.validationHandler) {\n        return options.validationHandler({\n          accessToken: accessToken,\n          idClaims: result.idTokenClaims,\n          idToken: result.idToken,\n          state: state\n        }).then(_ => result);\n      }\n\n      return result;\n    }).then(result => {\n      this.storeIdToken(result);\n      this.storeSessionState(sessionState);\n\n      if (this.clearHashAfterLogin && !options.preventClearHashAfterLogin) {\n        this.clearLocationHash();\n      }\n\n      this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n      this.callOnTokenReceivedIfExists(options);\n      this.inImplicitFlow = false;\n      return true;\n    }).catch(reason => {\n      this.eventsSubject.next(new OAuthErrorEvent('token_validation_error', reason));\n      this.logger.error('Error validating tokens');\n      this.logger.error(reason);\n      return Promise.reject(reason);\n    });\n  }\n\n  parseState(state) {\n    let nonce = state;\n    let userState = '';\n\n    if (state) {\n      const idx = state.indexOf(this.config.nonceStateSeparator);\n\n      if (idx > -1) {\n        nonce = state.substr(0, idx);\n        userState = state.substr(idx + this.config.nonceStateSeparator.length);\n      }\n    }\n\n    return [nonce, userState];\n  }\n\n  validateNonce(nonceInState) {\n    let savedNonce;\n\n    if (this.saveNoncesInLocalStorage && typeof window['localStorage'] !== 'undefined') {\n      savedNonce = localStorage.getItem('nonce');\n    } else {\n      savedNonce = this._storage.getItem('nonce');\n    }\n\n    if (savedNonce !== nonceInState) {\n      const err = 'Validating access_token failed, wrong state/nonce.';\n      console.error(err, savedNonce, nonceInState);\n      return false;\n    }\n\n    return true;\n  }\n\n  storeIdToken(idToken) {\n    this._storage.setItem('id_token', idToken.idToken);\n\n    this._storage.setItem('id_token_claims_obj', idToken.idTokenClaimsJson);\n\n    this._storage.setItem('id_token_expires_at', '' + idToken.idTokenExpiresAt);\n\n    this._storage.setItem('id_token_stored_at', '' + this.dateTimeService.now());\n  }\n\n  storeSessionState(sessionState) {\n    this._storage.setItem('session_state', sessionState);\n  }\n\n  getSessionState() {\n    return this._storage.getItem('session_state');\n  }\n\n  handleLoginError(options, parts) {\n    if (options.onLoginError) {\n      options.onLoginError(parts);\n    }\n\n    if (this.clearHashAfterLogin && !options.preventClearHashAfterLogin) {\n      this.clearLocationHash();\n    }\n  }\n\n  getClockSkewInMsec(defaultSkewMsc = 600000) {\n    if (!this.clockSkewInSec && this.clockSkewInSec !== 0) {\n      return defaultSkewMsc;\n    }\n\n    return this.clockSkewInSec * 1000;\n  }\n  /**\r\n   * @ignore\r\n   */\n\n\n  processIdToken(idToken, accessToken, skipNonceCheck = false) {\n    const tokenParts = idToken.split('.');\n    const headerBase64 = this.padBase64(tokenParts[0]);\n    const headerJson = b64DecodeUnicode(headerBase64);\n    const header = JSON.parse(headerJson);\n    const claimsBase64 = this.padBase64(tokenParts[1]);\n    const claimsJson = b64DecodeUnicode(claimsBase64);\n    const claims = JSON.parse(claimsJson);\n    let savedNonce;\n\n    if (this.saveNoncesInLocalStorage && typeof window['localStorage'] !== 'undefined') {\n      savedNonce = localStorage.getItem('nonce');\n    } else {\n      savedNonce = this._storage.getItem('nonce');\n    }\n\n    if (Array.isArray(claims.aud)) {\n      if (claims.aud.every(v => v !== this.clientId)) {\n        const err = 'Wrong audience: ' + claims.aud.join(',');\n        this.logger.warn(err);\n        return Promise.reject(err);\n      }\n    } else {\n      if (claims.aud !== this.clientId) {\n        const err = 'Wrong audience: ' + claims.aud;\n        this.logger.warn(err);\n        return Promise.reject(err);\n      }\n    }\n\n    if (!claims.sub) {\n      const err = 'No sub claim in id_token';\n      this.logger.warn(err);\n      return Promise.reject(err);\n    }\n    /* For now, we only check whether the sub against\r\n     * silentRefreshSubject when sessionChecksEnabled is on\r\n     * We will reconsider in a later version to do this\r\n     * in every other case too.\r\n     */\n\n\n    if (this.sessionChecksEnabled && this.silentRefreshSubject && this.silentRefreshSubject !== claims['sub']) {\n      const err = 'After refreshing, we got an id_token for another user (sub). ' + `Expected sub: ${this.silentRefreshSubject}, received sub: ${claims['sub']}`;\n      this.logger.warn(err);\n      return Promise.reject(err);\n    }\n\n    if (!claims.iat) {\n      const err = 'No iat claim in id_token';\n      this.logger.warn(err);\n      return Promise.reject(err);\n    }\n\n    if (!this.skipIssuerCheck && claims.iss !== this.issuer) {\n      const err = 'Wrong issuer: ' + claims.iss;\n      this.logger.warn(err);\n      return Promise.reject(err);\n    }\n\n    if (!skipNonceCheck && claims.nonce !== savedNonce) {\n      const err = 'Wrong nonce: ' + claims.nonce;\n      this.logger.warn(err);\n      return Promise.reject(err);\n    } // at_hash is not applicable to authorization code flow\n    // addressing https://github.com/manfredsteyer/angular-oauth2-oidc/issues/661\n    // i.e. Based on spec the at_hash check is only true for implicit code flow on Ping Federate\n    // https://www.pingidentity.com/developer/en/resources/openid-connect-developers-guide.html\n\n\n    if (this.hasOwnProperty('responseType') && (this.responseType === 'code' || this.responseType === 'id_token')) {\n      this.disableAtHashCheck = true;\n    }\n\n    if (!this.disableAtHashCheck && this.requestAccessToken && !claims['at_hash']) {\n      const err = 'An at_hash is needed!';\n      this.logger.warn(err);\n      return Promise.reject(err);\n    }\n\n    const now = this.dateTimeService.now();\n    const issuedAtMSec = claims.iat * 1000;\n    const expiresAtMSec = claims.exp * 1000;\n    const clockSkewInMSec = this.getClockSkewInMsec(); // (this.getClockSkewInMsec() || 600) * 1000;\n\n    if (issuedAtMSec - clockSkewInMSec >= now || expiresAtMSec + clockSkewInMSec - this.decreaseExpirationBySec <= now) {\n      const err = 'Token has expired';\n      console.error(err);\n      console.error({\n        now: now,\n        issuedAtMSec: issuedAtMSec,\n        expiresAtMSec: expiresAtMSec\n      });\n      return Promise.reject(err);\n    }\n\n    const validationParams = {\n      accessToken: accessToken,\n      idToken: idToken,\n      jwks: this.jwks,\n      idTokenClaims: claims,\n      idTokenHeader: header,\n      loadKeys: () => this.loadJwks()\n    };\n\n    if (this.disableAtHashCheck) {\n      return this.checkSignature(validationParams).then(_ => {\n        const result = {\n          idToken: idToken,\n          idTokenClaims: claims,\n          idTokenClaimsJson: claimsJson,\n          idTokenHeader: header,\n          idTokenHeaderJson: headerJson,\n          idTokenExpiresAt: expiresAtMSec\n        };\n        return result;\n      });\n    }\n\n    return this.checkAtHash(validationParams).then(atHashValid => {\n      if (!this.disableAtHashCheck && this.requestAccessToken && !atHashValid) {\n        const err = 'Wrong at_hash';\n        this.logger.warn(err);\n        return Promise.reject(err);\n      }\n\n      return this.checkSignature(validationParams).then(_ => {\n        const atHashCheckEnabled = !this.disableAtHashCheck;\n        const result = {\n          idToken: idToken,\n          idTokenClaims: claims,\n          idTokenClaimsJson: claimsJson,\n          idTokenHeader: header,\n          idTokenHeaderJson: headerJson,\n          idTokenExpiresAt: expiresAtMSec\n        };\n\n        if (atHashCheckEnabled) {\n          return this.checkAtHash(validationParams).then(atHashValid => {\n            if (this.requestAccessToken && !atHashValid) {\n              const err = 'Wrong at_hash';\n              this.logger.warn(err);\n              return Promise.reject(err);\n            } else {\n              return result;\n            }\n          });\n        } else {\n          return result;\n        }\n      });\n    });\n  }\n  /**\r\n   * Returns the received claims about the user.\r\n   */\n\n\n  getIdentityClaims() {\n    const claims = this._storage.getItem('id_token_claims_obj');\n\n    if (!claims) {\n      return null;\n    }\n\n    return JSON.parse(claims);\n  }\n  /**\r\n   * Returns the granted scopes from the server.\r\n   */\n\n\n  getGrantedScopes() {\n    const scopes = this._storage.getItem('granted_scopes');\n\n    if (!scopes) {\n      return null;\n    }\n\n    return JSON.parse(scopes);\n  }\n  /**\r\n   * Returns the current id_token.\r\n   */\n\n\n  getIdToken() {\n    return this._storage ? this._storage.getItem('id_token') : null;\n  }\n\n  padBase64(base64data) {\n    while (base64data.length % 4 !== 0) {\n      base64data += '=';\n    }\n\n    return base64data;\n  }\n  /**\r\n   * Returns the current access_token.\r\n   */\n\n\n  getAccessToken() {\n    return this._storage ? this._storage.getItem('access_token') : null;\n  }\n\n  getRefreshToken() {\n    return this._storage ? this._storage.getItem('refresh_token') : null;\n  }\n  /**\r\n   * Returns the expiration date of the access_token\r\n   * as milliseconds since 1970.\r\n   */\n\n\n  getAccessTokenExpiration() {\n    if (!this._storage.getItem('expires_at')) {\n      return null;\n    }\n\n    return parseInt(this._storage.getItem('expires_at'), 10);\n  }\n\n  getAccessTokenStoredAt() {\n    return parseInt(this._storage.getItem('access_token_stored_at'), 10);\n  }\n\n  getIdTokenStoredAt() {\n    return parseInt(this._storage.getItem('id_token_stored_at'), 10);\n  }\n  /**\r\n   * Returns the expiration date of the id_token\r\n   * as milliseconds since 1970.\r\n   */\n\n\n  getIdTokenExpiration() {\n    if (!this._storage.getItem('id_token_expires_at')) {\n      return null;\n    }\n\n    return parseInt(this._storage.getItem('id_token_expires_at'), 10);\n  }\n  /**\r\n   * Checkes, whether there is a valid access_token.\r\n   */\n\n\n  hasValidAccessToken() {\n    if (this.getAccessToken()) {\n      const expiresAt = this._storage.getItem('expires_at');\n\n      const now = this.dateTimeService.new();\n\n      if (expiresAt && parseInt(expiresAt, 10) - this.decreaseExpirationBySec < now.getTime() - this.getClockSkewInMsec()) {\n        return false;\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\r\n   * Checks whether there is a valid id_token.\r\n   */\n\n\n  hasValidIdToken() {\n    if (this.getIdToken()) {\n      const expiresAt = this._storage.getItem('id_token_expires_at');\n\n      const now = this.dateTimeService.new();\n\n      if (expiresAt && parseInt(expiresAt, 10) - this.decreaseExpirationBySec < now.getTime() - this.getClockSkewInMsec()) {\n        return false;\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\r\n   * Retrieve a saved custom property of the TokenReponse object. Only if predefined in authconfig.\r\n   */\n\n\n  getCustomTokenResponseProperty(requestedProperty) {\n    return this._storage && this.config.customTokenParameters && this.config.customTokenParameters.indexOf(requestedProperty) >= 0 && this._storage.getItem(requestedProperty) !== null ? JSON.parse(this._storage.getItem(requestedProperty)) : null;\n  }\n  /**\r\n   * Returns the auth-header that can be used\r\n   * to transmit the access_token to a service\r\n   */\n\n\n  authorizationHeader() {\n    return 'Bearer ' + this.getAccessToken();\n  }\n\n  logOut(customParameters = {}, state = '') {\n    let noRedirectToLogoutUrl = false;\n\n    if (typeof customParameters === 'boolean') {\n      noRedirectToLogoutUrl = customParameters;\n      customParameters = {};\n    }\n\n    const id_token = this.getIdToken();\n\n    this._storage.removeItem('access_token');\n\n    this._storage.removeItem('id_token');\n\n    this._storage.removeItem('refresh_token');\n\n    if (this.saveNoncesInLocalStorage) {\n      localStorage.removeItem('nonce');\n      localStorage.removeItem('PKCE_verifier');\n    } else {\n      this._storage.removeItem('nonce');\n\n      this._storage.removeItem('PKCE_verifier');\n    }\n\n    this._storage.removeItem('expires_at');\n\n    this._storage.removeItem('id_token_claims_obj');\n\n    this._storage.removeItem('id_token_expires_at');\n\n    this._storage.removeItem('id_token_stored_at');\n\n    this._storage.removeItem('access_token_stored_at');\n\n    this._storage.removeItem('granted_scopes');\n\n    this._storage.removeItem('session_state');\n\n    if (this.config.customTokenParameters) {\n      this.config.customTokenParameters.forEach(customParam => this._storage.removeItem(customParam));\n    }\n\n    this.silentRefreshSubject = null;\n    this.eventsSubject.next(new OAuthInfoEvent('logout'));\n\n    if (!this.logoutUrl) {\n      return;\n    }\n\n    if (noRedirectToLogoutUrl) {\n      return;\n    } // if (!id_token && !this.postLogoutRedirectUri) {\n    //   return;\n    // }\n\n\n    let logoutUrl;\n\n    if (!this.validateUrlForHttps(this.logoutUrl)) {\n      throw new Error(\"logoutUrl  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\");\n    } // For backward compatibility\n\n\n    if (this.logoutUrl.indexOf('{{') > -1) {\n      logoutUrl = this.logoutUrl.replace(/\\{\\{id_token\\}\\}/, encodeURIComponent(id_token)).replace(/\\{\\{client_id\\}\\}/, encodeURIComponent(this.clientId));\n    } else {\n      let params = new HttpParams({\n        encoder: new WebHttpUrlEncodingCodec()\n      });\n\n      if (id_token) {\n        params = params.set('id_token_hint', id_token);\n      }\n\n      const postLogoutUrl = this.postLogoutRedirectUri || this.redirectUriAsPostLogoutRedirectUriFallback && this.redirectUri || '';\n\n      if (postLogoutUrl) {\n        params = params.set('post_logout_redirect_uri', postLogoutUrl);\n\n        if (state) {\n          params = params.set('state', state);\n        }\n      }\n\n      for (let key in customParameters) {\n        params = params.set(key, customParameters[key]);\n      }\n\n      logoutUrl = this.logoutUrl + (this.logoutUrl.indexOf('?') > -1 ? '&' : '?') + params.toString();\n    }\n\n    this.config.openUri(logoutUrl);\n  }\n  /**\r\n   * @ignore\r\n   */\n\n\n  createAndSaveNonce() {\n    const that = this;\n    return this.createNonce().then(function (nonce) {\n      // Use localStorage for nonce if possible\n      // localStorage is the only storage who survives a\n      // redirect in ALL browsers (also IE)\n      // Otherwiese we'd force teams who have to support\n      // IE into using localStorage for everything\n      if (that.saveNoncesInLocalStorage && typeof window['localStorage'] !== 'undefined') {\n        localStorage.setItem('nonce', nonce);\n      } else {\n        that._storage.setItem('nonce', nonce);\n      }\n\n      return nonce;\n    });\n  }\n  /**\r\n   * @ignore\r\n   */\n\n\n  ngOnDestroy() {\n    this.clearAccessTokenTimer();\n    this.clearIdTokenTimer();\n    this.removeSilentRefreshEventListener();\n    const silentRefreshFrame = this.document.getElementById(this.silentRefreshIFrameName);\n\n    if (silentRefreshFrame) {\n      silentRefreshFrame.remove();\n    }\n\n    this.stopSessionCheckTimer();\n    this.removeSessionCheckEventListener();\n    const sessionCheckFrame = this.document.getElementById(this.sessionCheckIFrameName);\n\n    if (sessionCheckFrame) {\n      sessionCheckFrame.remove();\n    }\n  }\n\n  createNonce() {\n    return new Promise(resolve => {\n      if (this.rngUrl) {\n        throw new Error('createNonce with rng-web-api has not been implemented so far');\n      }\n      /*\r\n       * This alphabet is from:\r\n       * https://tools.ietf.org/html/rfc7636#section-4.1\r\n       *\r\n       * [A-Z] / [a-z] / [0-9] / \"-\" / \".\" / \"_\" / \"~\"\r\n       */\n\n\n      const unreserved = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';\n      let size = 45;\n      let id = '';\n      const crypto = typeof self === 'undefined' ? null : self.crypto || self['msCrypto'];\n\n      if (crypto) {\n        let bytes = new Uint8Array(size);\n        crypto.getRandomValues(bytes); // Needed for IE\n\n        if (!bytes.map) {\n          bytes.map = Array.prototype.map;\n        }\n\n        bytes = bytes.map(x => unreserved.charCodeAt(x % unreserved.length));\n        id = String.fromCharCode.apply(null, bytes);\n      } else {\n        while (0 < size--) {\n          id += unreserved[Math.random() * unreserved.length | 0];\n        }\n      }\n\n      resolve(base64UrlEncode(id));\n    });\n  }\n\n  checkAtHash(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.tokenValidationHandler) {\n        this.logger.warn('No tokenValidationHandler configured. Cannot check at_hash.');\n        return true;\n      }\n\n      return this.tokenValidationHandler.validateAtHash(params);\n    });\n  }\n\n  checkSignature(params) {\n    if (!this.tokenValidationHandler) {\n      this.logger.warn('No tokenValidationHandler configured. Cannot check signature.');\n      return Promise.resolve(null);\n    }\n\n    return this.tokenValidationHandler.validateSignature(params);\n  }\n  /**\r\n   * Start the implicit flow or the code flow,\r\n   * depending on your configuration.\r\n   */\n\n\n  initLoginFlow(additionalState = '', params = {}) {\n    if (this.responseType === 'code') {\n      return this.initCodeFlow(additionalState, params);\n    } else {\n      return this.initImplicitFlow(additionalState, params);\n    }\n  }\n  /**\r\n   * Starts the authorization code flow and redirects to user to\r\n   * the auth servers login url.\r\n   */\n\n\n  initCodeFlow(additionalState = '', params = {}) {\n    if (this.loginUrl !== '') {\n      this.initCodeFlowInternal(additionalState, params);\n    } else {\n      this.events.pipe(filter(e => e.type === 'discovery_document_loaded')).subscribe(_ => this.initCodeFlowInternal(additionalState, params));\n    }\n  }\n\n  initCodeFlowInternal(additionalState = '', params = {}) {\n    if (!this.validateUrlForHttps(this.loginUrl)) {\n      throw new Error(\"loginUrl  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\");\n    }\n\n    let addParams = {};\n    let loginHint = null;\n\n    if (typeof params === 'string') {\n      loginHint = params;\n    } else if (typeof params === 'object') {\n      addParams = params;\n    }\n\n    this.createLoginUrl(additionalState, loginHint, null, false, addParams).then(this.config.openUri).catch(error => {\n      console.error('Error in initAuthorizationCodeFlow');\n      console.error(error);\n    });\n  }\n\n  createChallangeVerifierPairForPKCE() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.crypto) {\n        throw new Error('PKCE support for code flow needs a CryptoHander. Did you import the OAuthModule using forRoot() ?');\n      }\n\n      const verifier = yield this.createNonce();\n      const challengeRaw = yield this.crypto.calcHash(verifier, 'sha-256');\n      const challenge = base64UrlEncode(challengeRaw);\n      return [challenge, verifier];\n    });\n  }\n\n  extractRecognizedCustomParameters(tokenResponse) {\n    let foundParameters = new Map();\n\n    if (!this.config.customTokenParameters) {\n      return foundParameters;\n    }\n\n    this.config.customTokenParameters.forEach(recognizedParameter => {\n      if (tokenResponse[recognizedParameter]) {\n        foundParameters.set(recognizedParameter, JSON.stringify(tokenResponse[recognizedParameter]));\n      }\n    });\n    return foundParameters;\n  }\n  /**\r\n   * Revokes the auth token to secure the vulnarability\r\n   * of the token issued allowing the authorization server to clean\r\n   * up any security credentials associated with the authorization\r\n   */\n\n\n  revokeTokenAndLogout(customParameters = {}, ignoreCorsIssues = false) {\n    let revokeEndpoint = this.revocationEndpoint;\n    let accessToken = this.getAccessToken();\n    let refreshToken = this.getRefreshToken();\n\n    if (!accessToken) {\n      return Promise.resolve();\n    }\n\n    let params = new HttpParams({\n      encoder: new WebHttpUrlEncodingCodec()\n    });\n    let headers = new HttpHeaders().set('Content-Type', 'application/x-www-form-urlencoded');\n\n    if (this.useHttpBasicAuth) {\n      const header = btoa(`${this.clientId}:${this.dummyClientSecret}`);\n      headers = headers.set('Authorization', 'Basic ' + header);\n    }\n\n    if (!this.useHttpBasicAuth) {\n      params = params.set('client_id', this.clientId);\n    }\n\n    if (!this.useHttpBasicAuth && this.dummyClientSecret) {\n      params = params.set('client_secret', this.dummyClientSecret);\n    }\n\n    if (this.customQueryParams) {\n      for (const key of Object.getOwnPropertyNames(this.customQueryParams)) {\n        params = params.set(key, this.customQueryParams[key]);\n      }\n    }\n\n    return new Promise((resolve, reject) => {\n      let revokeAccessToken;\n      let revokeRefreshToken;\n\n      if (accessToken) {\n        let revokationParams = params.set('token', accessToken).set('token_type_hint', 'access_token');\n        revokeAccessToken = this.http.post(revokeEndpoint, revokationParams, {\n          headers\n        });\n      } else {\n        revokeAccessToken = of(null);\n      }\n\n      if (refreshToken) {\n        let revokationParams = params.set('token', refreshToken).set('token_type_hint', 'refresh_token');\n        revokeRefreshToken = this.http.post(revokeEndpoint, revokationParams, {\n          headers\n        });\n      } else {\n        revokeRefreshToken = of(null);\n      }\n\n      if (ignoreCorsIssues) {\n        revokeAccessToken = revokeAccessToken.pipe(catchError(err => {\n          if (err.status === 0) {\n            return of(null);\n          }\n\n          return throwError(err);\n        }));\n        revokeRefreshToken = revokeRefreshToken.pipe(catchError(err => {\n          if (err.status === 0) {\n            return of(null);\n          }\n\n          return throwError(err);\n        }));\n      }\n\n      combineLatest([revokeAccessToken, revokeRefreshToken]).subscribe(res => {\n        this.logOut(customParameters);\n        resolve(res);\n        this.logger.info('Token successfully revoked');\n      }, err => {\n        this.logger.error('Error revoking token', err);\n        this.eventsSubject.next(new OAuthErrorEvent('token_revoke_error', err));\n        reject(err);\n      });\n    });\n  }\n  /**\r\n   * Clear location.hash if it's present\r\n   */\n\n\n  clearLocationHash() {\n    // Checking for empty hash is necessary for Firefox\n    // as setting an empty hash to an empty string adds # to the URL\n    if (location.hash != '') {\n      location.hash = '';\n    }\n  }\n\n}\n\nOAuthService.ɵfac = function OAuthService_Factory(t) {\n  return new (t || OAuthService)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(OAuthStorage, 8), i0.ɵɵinject(ValidationHandler, 8), i0.ɵɵinject(AuthConfig, 8), i0.ɵɵinject(UrlHelperService), i0.ɵɵinject(OAuthLogger), i0.ɵɵinject(HashHandler, 8), i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(DateTimeProvider));\n};\n\nOAuthService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: OAuthService,\n  factory: OAuthService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OAuthService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i0.NgZone\n    }, {\n      type: i1.HttpClient\n    }, {\n      type: OAuthStorage,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: ValidationHandler,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: AuthConfig,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: UrlHelperService\n    }, {\n      type: OAuthLogger\n    }, {\n      type: HashHandler,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: DateTimeProvider\n    }];\n  }, null);\n})();\n\nclass OAuthResourceServerErrorHandler {}\n\nclass OAuthNoopResourceServerErrorHandler {\n  handleError(err) {\n    return throwError(err);\n  }\n\n}\n\nclass DefaultOAuthInterceptor {\n  constructor(oAuthService, errorHandler, moduleConfig) {\n    this.oAuthService = oAuthService;\n    this.errorHandler = errorHandler;\n    this.moduleConfig = moduleConfig;\n  }\n\n  checkUrl(url) {\n    if (this.moduleConfig.resourceServer.customUrlValidation) {\n      return this.moduleConfig.resourceServer.customUrlValidation(url);\n    }\n\n    if (this.moduleConfig.resourceServer.allowedUrls) {\n      return !!this.moduleConfig.resourceServer.allowedUrls.find(u => url.toLowerCase().startsWith(u.toLowerCase()));\n    }\n\n    return true;\n  }\n\n  intercept(req, next) {\n    const url = req.url.toLowerCase();\n\n    if (!this.moduleConfig || !this.moduleConfig.resourceServer || !this.checkUrl(url)) {\n      return next.handle(req);\n    }\n\n    const sendAccessToken = this.moduleConfig.resourceServer.sendAccessToken;\n\n    if (!sendAccessToken) {\n      return next.handle(req).pipe(catchError(err => this.errorHandler.handleError(err)));\n    }\n\n    return merge(of(this.oAuthService.getAccessToken()).pipe(filter(token => !!token)), this.oAuthService.events.pipe(filter(e => e.type === 'token_received'), timeout(this.oAuthService.waitForTokenInMsec || 0), catchError(_ => of(null)), // timeout is not an error\n    map(_ => this.oAuthService.getAccessToken()))).pipe(take(1), mergeMap(token => {\n      if (token) {\n        const header = 'Bearer ' + token;\n        const headers = req.headers.set('Authorization', header);\n        req = req.clone({\n          headers\n        });\n      }\n\n      return next.handle(req).pipe(catchError(err => this.errorHandler.handleError(err)));\n    }));\n  }\n\n}\n\nDefaultOAuthInterceptor.ɵfac = function DefaultOAuthInterceptor_Factory(t) {\n  return new (t || DefaultOAuthInterceptor)(i0.ɵɵinject(OAuthService), i0.ɵɵinject(OAuthResourceServerErrorHandler), i0.ɵɵinject(OAuthModuleConfig, 8));\n};\n\nDefaultOAuthInterceptor.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DefaultOAuthInterceptor,\n  factory: DefaultOAuthInterceptor.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DefaultOAuthInterceptor, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: OAuthService\n    }, {\n      type: OAuthResourceServerErrorHandler\n    }, {\n      type: OAuthModuleConfig,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n\nfunction createDefaultLogger() {\n  return console;\n}\n\nfunction createDefaultStorage() {\n  return typeof sessionStorage !== 'undefined' ? sessionStorage : new MemoryStorage();\n}\n\nfunction provideOAuthClient(config = null, validationHandlerClass = NullValidationHandler) {\n  return makeEnvironmentProviders([OAuthService, UrlHelperService, {\n    provide: OAuthLogger,\n    useFactory: createDefaultLogger\n  }, {\n    provide: OAuthStorage,\n    useFactory: createDefaultStorage\n  }, {\n    provide: ValidationHandler,\n    useClass: validationHandlerClass\n  }, {\n    provide: HashHandler,\n    useClass: DefaultHashHandler\n  }, {\n    provide: OAuthResourceServerErrorHandler,\n    useClass: OAuthNoopResourceServerErrorHandler\n  }, {\n    provide: OAuthModuleConfig,\n    useValue: config\n  }, {\n    provide: HTTP_INTERCEPTORS,\n    useClass: DefaultOAuthInterceptor,\n    multi: true\n  }, {\n    provide: DateTimeProvider,\n    useClass: SystemDateTimeProvider\n  }]);\n}\n\nclass OAuthModule {\n  static forRoot(config = null, validationHandlerClass = NullValidationHandler) {\n    return {\n      ngModule: OAuthModule,\n      providers: [provideOAuthClient(config, validationHandlerClass)]\n    };\n  }\n\n}\n\nOAuthModule.ɵfac = function OAuthModule_Factory(t) {\n  return new (t || OAuthModule)();\n};\n\nOAuthModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: OAuthModule\n});\nOAuthModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [CommonModule]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OAuthModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule],\n      declarations: [],\n      exports: []\n    }]\n  }], null, null);\n})();\n\nconst err = `PLEASE READ THIS CAREFULLY:\n\nBeginning with angular-oauth2-oidc version 9, the JwksValidationHandler\nhas been moved to an library of its own. If you need it for implementing\nOAuth2/OIDC **implicit flow**, please install it using npm:\n\n  npm i angular-oauth2-oidc-jwks --save\n\nAfter that, you can import it into your application:\n\n  import { JwksValidationHandler } from 'angular-oauth2-oidc-jwks';\n\nPlease note, that this dependency is not needed for the **code flow**,\nwhich is nowadays the **recommented** one for single page applications.\nThis also results in smaller bundle sizes.\n`;\n/**\r\n * This is just a dummy of the JwksValidationHandler\r\n * telling the users that the real one has been moved\r\n * to an library of its own, namely angular-oauth2-oidc-utils\r\n */\n\nclass JwksValidationHandler extends NullValidationHandler {\n  constructor() {\n    super();\n    console.error(err);\n  }\n\n}\n\nconst AUTH_CONFIG = new InjectionToken('AUTH_CONFIG');\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { AUTH_CONFIG, AbstractValidationHandler, AuthConfig, DateTimeProvider, DefaultHashHandler, DefaultOAuthInterceptor, HashHandler, JwksValidationHandler, LoginOptions, MemoryStorage, NullValidationHandler, OAuthErrorEvent, OAuthEvent, OAuthInfoEvent, OAuthLogger, OAuthModule, OAuthModuleConfig, OAuthNoopResourceServerErrorHandler, OAuthResourceServerConfig, OAuthResourceServerErrorHandler, OAuthService, OAuthStorage, OAuthSuccessEvent, ReceivedTokens, SystemDateTimeProvider, UrlHelperService, ValidationHandler, provideOAuthClient };","map":{"version":3,"names":["i0","Injectable","Optional","Inject","makeEnvironmentProviders","NgModule","InjectionToken","DOCUMENT","CommonModule","i1","HttpHeaders","HttpParams","HTTP_INTERCEPTORS","__awaiter","Subject","of","from","race","throwError","combineLatest","merge","filter","tap","debounceTime","delay","switchMap","map","first","catchError","timeout","take","mergeMap","NullValidationHandler","validateSignature","validationParams","Promise","resolve","validateAtHash","OAuthModuleConfig","OAuthResourceServerConfig","DateTimeProvider","SystemDateTimeProvider","now","Date","new","ɵfac","ɵprov","type","LoginOptions","constructor","disableNonceCheck","preventClearHashAfterLogin","OAuthLogger","OAuthStorage","MemoryStorage","data","Map","getItem","key","get","removeItem","delete","setItem","set","ReceivedTokens","OAuthEvent","OAuthSuccessEvent","info","OAuthInfoEvent","OAuthErrorEvent","reason","params","b64DecodeUnicode","str","base64","replace","decodeURIComponent","atob","split","c","charCodeAt","toString","slice","join","base64UrlEncode","btoa","AuthConfig","json","clientId","redirectUri","postLogoutRedirectUri","redirectUriAsPostLogoutRedirectUriFallback","loginUrl","scope","resource","rngUrl","oidc","requestAccessToken","options","issuer","logoutUrl","clearHashAfterLogin","tokenEndpoint","revocationEndpoint","customTokenParameters","userinfoEndpoint","responseType","showDebugInformation","silentRefreshRedirectUri","silentRefreshMessagePrefix","silentRefreshShowIFrame","siletRefreshTimeout","silentRefreshTimeout","dummyClientSecret","requireHttps","strictDiscoveryDocumentValidation","jwks","customQueryParams","silentRefreshIFrameName","timeoutFactor","sessionChecksEnabled","sessionCheckIntervall","sessionCheckIFrameUrl","sessionCheckIFrameName","disableAtHashCheck","skipSubjectCheck","useIdTokenHintForSilentRefresh","skipIssuerCheck","nonceStateSeparator","useHttpBasicAuth","decreaseExpirationBySec","waitForTokenInMsec","disablePKCE","preserveRequestedRoute","disableIdTokenTimer","checkOrigin","openUri","uri","location","href","Object","assign","WebHttpUrlEncodingCodec","encodeKey","k","encodeURIComponent","encodeValue","v","decodeKey","decodeValue","ValidationHandler","AbstractValidationHandler","hashAlg","inferHashAlgorithm","idTokenHeader","tokenHash","calcHash","accessToken","leftMostHalf","substr","length","atHash","claimsAtHash","idTokenClaims","console","error","jwtHeader","alg","match","Error","UrlHelperService","getHashFragmentParams","customHashFragment","hash","window","indexOf","questionMarkPosition","parseQueryString","queryString","pairs","pair","separatorIndex","escapedKey","escapedValue","value","i","digestLength","blockSize","K","Uint32Array","hashBlocks","w","p","pos","len","a","b","d","e","f","g","h","u","j","t1","t2","Hash","state","Int32Array","temp","buffer","Uint8Array","bufferLength","bytesHashed","finished","reset","clean","update","dataLength","dataPos","finish","out","left","bitLenHi","bitLenLo","padLength","digest","_saveState","_restoreState","HMAC","inner","outer","pad","istate","ostate","hmac","fillBuffer","counter","num","hkdfSalt","hkdf","salt","okm","hmac_","bufpos","fill","pbkdf2","password","iterations","dkLen","prf","ctr","t","dk","HashHandler","decodeUTF8","s","TypeError","encodeUTF8","arr","push","String","fromCharCode","DefaultHashHandler","valueToHash","algorithm","candHash","toHashString2","byteArray","result","toHashString","OAuthService","ngZone","http","storage","tokenValidationHandler","config","urlHelper","logger","crypto","document","dateTimeService","_a","discoveryDocumentLoaded","eventsSubject","discoveryDocumentLoadedSubject","grantTypesSupported","inImplicitFlow","saveNoncesInLocalStorage","debug","discoveryDocumentLoaded$","asObservable","events","configure","setStorage","sessionStorage","checkLocalStorageAccessable","ua","navigator","userAgent","msie","includes","setupRefreshTimer","test","localStorage","setupSessionCheck","configChanged","restartSessionChecksIfStillLoggedIn","hasValidIdToken","initSessionCheck","restartRefreshTimerIfStillLoggedIn","setupExpirationTimers","pipe","subscribe","setupAutomaticSilentRefresh","listenTo","noPrompt","shouldRunSilentRefresh","clearAutomaticRefreshTimer","automaticRefreshSubscription","_","refreshInternal","catch","useSilentRefresh","refreshToken","silentRefresh","loadDiscoveryDocumentAndTryLogin","loadDiscoveryDocument","then","doc","tryLogin","loadDiscoveryDocumentAndLogin","hasValidAccessToken","initLoginFlow","args","apply","validateUrlFromDiscoveryDocument","url","errors","httpsCheck","validateUrlForHttps","issuerCheck","validateUrlAgainstIssuer","lcUrl","toLowerCase","startsWith","assertUrlNotNullAndCorrectProtocol","description","clearAccessTokenTimer","clearIdTokenTimer","tokenReceivedSubscription","unsubscribe","setupAccessTokenTimer","setupIdTokenTimer","expiration","getAccessTokenExpiration","storedAt","getAccessTokenStoredAt","calcTimeout","runOutsideAngular","accessTokenTimeoutSubscription","run","next","getIdTokenExpiration","getIdTokenStoredAt","idTokenTimeoutSubscription","stopAutomaticRefresh","delta","duration","Math","max","maxTimeoutValue","_storage","fullUrl","reject","endsWith","validateDiscoveryDocument","authorization_endpoint","end_session_endpoint","grant_types_supported","token_endpoint","userinfo_endpoint","jwksUri","jwks_uri","check_session_iframe","revocation_endpoint","loadJwks","discoveryDocument","event","err","warn","fetchTokenUsingPasswordFlowAndLoadUserProfile","userName","headers","fetchTokenUsingPasswordFlow","loadUserProfile","getAccessToken","observe","response","JSON","stringify","parse","body","existingClaims","getIdentityClaims","sub","parameters","username","fetchTokenUsingGrant","grantType","encoder","header","getOwnPropertyNames","keys","post","tokenResponse","storeAccessTokenResponse","access_token","refresh_token","expires_in","fallbackAccessTokenExpirationTimeInSec","extractRecognizedCustomParameters","id_token","processIdToken","storeIdToken","removeSilentRefreshEventListener","silentRefreshPostMessageEventListener","removeEventListener","setupSilentRefreshEventListener","message","processMessageEventMessage","origin","customRedirectUri","addEventListener","claims","getIdToken","existingIframe","getElementById","removeChild","silentRefreshSubject","iframe","createElement","id","createLoginUrl","setAttribute","style","appendChild","success","toPromise","initImplicitFlowInPopup","initLoginFlowInPopup","display","checkForPopupClosedInterval","windowRef","open","calculatePopupFeatures","closed","checkForPopupClosedTimer","cleanup","checkForPopupClosed","setInterval","clearInterval","storageListener","listener","close","log","newValue","height","width","screenLeft","outerWidth","top","screenTop","outerHeight","expectedPrefix","prefixedMessage","canPerformSessionCheck","sessionState","getSessionState","setupSessionCheckEventListener","removeSessionCheckEventListener","sessionCheckEventListener","handleSessionUnchanged","handleSessionChange","handleSessionError","stopSessionCheckTimer","logOut","waitForSilentRefreshAfterSessionChange","startSessionCheckTimer","sessionCheckTimer","checkSession","bind","contentWindow","postMessage","loginHint","that","nonce","createAndSaveNonce","seperationChar","challenge","verifier","createChallangeVerifierPairForPKCE","initImplicitFlowInternal","additionalState","addParams","initImplicitFlow","resetImplicitFlow","callOnTokenReceivedIfExists","onTokenReceived","tokenParams","idClaims","idToken","expiresIn","grantedScopes","customParameters","Array","isArray","expiresInMilliSeconds","expiresAt","getTime","forEach","tryLoginCodeFlow","tryLoginImplicitFlow","charAt","querySource","substring","search","parts","getCodePartsFromUrl","code","pathname","history","replaceState","name","nonceInState","userState","parseState","handleLoginError","saveRequestedRoute","disableOAuth2StateCheck","validateNonce","storeSessionState","getTokenFromCode","restoreRequestedRoute","requestedRoute","PKCEVerifier","fetchAndProcessToken","clearLocationHash","validationHandler","idx","savedNonce","idTokenClaimsJson","idTokenExpiresAt","onLoginError","getClockSkewInMsec","defaultSkewMsc","clockSkewInSec","skipNonceCheck","tokenParts","headerBase64","padBase64","headerJson","claimsBase64","claimsJson","aud","every","iat","iss","hasOwnProperty","issuedAtMSec","expiresAtMSec","exp","clockSkewInMSec","loadKeys","checkSignature","idTokenHeaderJson","checkAtHash","atHashValid","atHashCheckEnabled","getGrantedScopes","scopes","base64data","getRefreshToken","parseInt","getCustomTokenResponseProperty","requestedProperty","authorizationHeader","noRedirectToLogoutUrl","customParam","postLogoutUrl","createNonce","ngOnDestroy","silentRefreshFrame","remove","sessionCheckFrame","unreserved","size","self","bytes","getRandomValues","prototype","x","random","initCodeFlow","initCodeFlowInternal","challengeRaw","foundParameters","recognizedParameter","revokeTokenAndLogout","ignoreCorsIssues","revokeEndpoint","revokeAccessToken","revokeRefreshToken","revokationParams","status","res","NgZone","HttpClient","decorators","undefined","OAuthResourceServerErrorHandler","OAuthNoopResourceServerErrorHandler","handleError","DefaultOAuthInterceptor","oAuthService","errorHandler","moduleConfig","checkUrl","resourceServer","customUrlValidation","allowedUrls","find","intercept","req","handle","sendAccessToken","token","clone","createDefaultLogger","createDefaultStorage","provideOAuthClient","validationHandlerClass","provide","useFactory","useClass","useValue","multi","OAuthModule","forRoot","ngModule","providers","ɵmod","ɵinj","imports","declarations","exports","JwksValidationHandler","AUTH_CONFIG"],"sources":["D:/Projects/NavUdayArchitecture/NavUdayArchitecture/ClientApp/node_modules/angular-oauth2-oidc/fesm2015/angular-oauth2-oidc.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { Injectable, Optional, Inject, makeEnvironmentProviders, NgModule, InjectionToken } from '@angular/core';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport * as i1 from '@angular/common/http';\nimport { HttpHeaders, HttpParams, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { __awaiter } from 'tslib';\nimport { Subject, of, from, race, throwError, combineLatest, merge } from 'rxjs';\nimport { filter, tap, debounceTime, delay, switchMap, map, first, catchError, timeout, take, mergeMap } from 'rxjs/operators';\n\n/**\r\n * A validation handler that isn't validating nothing.\r\n * Can be used to skip validation (at your own risk).\r\n */\r\nclass NullValidationHandler {\r\n    validateSignature(validationParams) {\r\n        return Promise.resolve(null);\r\n    }\r\n    validateAtHash(validationParams) {\r\n        return Promise.resolve(true);\r\n    }\r\n}\n\nclass OAuthModuleConfig {\r\n}\r\nclass OAuthResourceServerConfig {\r\n}\n\nclass DateTimeProvider {\r\n}\r\nclass SystemDateTimeProvider extends DateTimeProvider {\r\n    now() {\r\n        return Date.now();\r\n    }\r\n    new() {\r\n        return new Date();\r\n    }\r\n}\r\nSystemDateTimeProvider.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: SystemDateTimeProvider, deps: null, target: i0.ɵɵFactoryTarget.Injectable });\r\nSystemDateTimeProvider.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: SystemDateTimeProvider });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: SystemDateTimeProvider, decorators: [{\r\n            type: Injectable\r\n        }] });\n\n/**\r\n * Additional options that can be passed to tryLogin.\r\n */\r\nclass LoginOptions {\r\n    constructor() {\r\n        /**\r\n         * Set this to true to disable the nonce\r\n         * check which is used to avoid\r\n         * replay attacks.\r\n         * This flag should never be true in\r\n         * production environments.\r\n         */\r\n        this.disableNonceCheck = false;\r\n        /**\r\n         * Normally, you want to clear your hash fragment after\r\n         * the lib read the token(s) so that they are not displayed\r\n         * anymore in the url. If not, set this to true. For code flow\r\n         * this controls removing query string values.\r\n         */\r\n        this.preventClearHashAfterLogin = false;\r\n    }\r\n}\r\n/**\r\n * Defines the logging interface the OAuthService uses\r\n * internally. Is compatible with the `console` object,\r\n * but you can provide your own implementation as well\r\n * through dependency injection.\r\n */\r\nclass OAuthLogger {\r\n}\r\n/**\r\n * Defines a simple storage that can be used for\r\n * storing the tokens at client side.\r\n * Is compatible to localStorage and sessionStorage,\r\n * but you can also create your own implementations.\r\n */\r\nclass OAuthStorage {\r\n}\r\nclass MemoryStorage {\r\n    constructor() {\r\n        this.data = new Map();\r\n    }\r\n    getItem(key) {\r\n        return this.data.get(key);\r\n    }\r\n    removeItem(key) {\r\n        this.data.delete(key);\r\n    }\r\n    setItem(key, data) {\r\n        this.data.set(key, data);\r\n    }\r\n}\r\nMemoryStorage.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: MemoryStorage, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nMemoryStorage.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: MemoryStorage });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: MemoryStorage, decorators: [{\r\n            type: Injectable\r\n        }] });\r\n/**\r\n * Represents the received tokens, the received state\r\n * and the parsed claims from the id-token.\r\n */\r\nclass ReceivedTokens {\r\n}\n\nclass OAuthEvent {\r\n    constructor(type) {\r\n        this.type = type;\r\n    }\r\n}\r\nclass OAuthSuccessEvent extends OAuthEvent {\r\n    constructor(type, info = null) {\r\n        super(type);\r\n        this.info = info;\r\n    }\r\n}\r\nclass OAuthInfoEvent extends OAuthEvent {\r\n    constructor(type, info = null) {\r\n        super(type);\r\n        this.info = info;\r\n    }\r\n}\r\nclass OAuthErrorEvent extends OAuthEvent {\r\n    constructor(type, reason, params = null) {\r\n        super(type);\r\n        this.reason = reason;\r\n        this.params = params;\r\n    }\r\n}\n\n// see: https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#The_.22Unicode_Problem.22\r\nfunction b64DecodeUnicode(str) {\r\n    const base64 = str.replace(/\\-/g, '+').replace(/\\_/g, '/');\r\n    return decodeURIComponent(atob(base64)\r\n        .split('')\r\n        .map(function (c) {\r\n        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\r\n    })\r\n        .join(''));\r\n}\r\nfunction base64UrlEncode(str) {\r\n    const base64 = btoa(str);\r\n    return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\r\n}\n\nclass AuthConfig {\r\n    constructor(json) {\r\n        /**\r\n         * The client's id as registered with the auth server\r\n         */\r\n        this.clientId = '';\r\n        /**\r\n         * The client's redirectUri as registered with the auth server\r\n         */\r\n        this.redirectUri = '';\r\n        /**\r\n         * An optional second redirectUri where the auth server\r\n         * redirects the user to after logging out.\r\n         */\r\n        this.postLogoutRedirectUri = '';\r\n        /**\r\n         * Defines whether to use 'redirectUri' as a replacement\r\n         * of 'postLogoutRedirectUri' if the latter is not set.\r\n         */\r\n        this.redirectUriAsPostLogoutRedirectUriFallback = true;\r\n        /**\r\n         * The auth server's endpoint that allows to log\r\n         * the user in when using implicit flow.\r\n         */\r\n        this.loginUrl = '';\r\n        /**\r\n         * The requested scopes\r\n         */\r\n        this.scope = 'openid profile';\r\n        this.resource = '';\r\n        this.rngUrl = '';\r\n        /**\r\n         * Defines whether to use OpenId Connect during\r\n         * implicit flow.\r\n         */\r\n        this.oidc = true;\r\n        /**\r\n         * Defines whether to request an access token during\r\n         * implicit flow.\r\n         */\r\n        this.requestAccessToken = true;\r\n        this.options = null;\r\n        /**\r\n         * The issuer's uri.\r\n         */\r\n        this.issuer = '';\r\n        /**\r\n         * The logout url.\r\n         */\r\n        this.logoutUrl = '';\r\n        /**\r\n         * Defines whether to clear the hash fragment after logging in.\r\n         */\r\n        this.clearHashAfterLogin = true;\r\n        /**\r\n         * Url of the token endpoint as defined by OpenId Connect and OAuth 2.\r\n         */\r\n        this.tokenEndpoint = null;\r\n        /**\r\n         * Url of the revocation endpoint as defined by OpenId Connect and OAuth 2.\r\n         */\r\n        this.revocationEndpoint = null;\r\n        /**\r\n         * Names of known parameters sent out in the TokenResponse. https://tools.ietf.org/html/rfc6749#section-5.1\r\n         */\r\n        this.customTokenParameters = [];\r\n        /**\r\n         * Url of the userinfo endpoint as defined by OpenId Connect.\r\n         */\r\n        this.userinfoEndpoint = null;\r\n        this.responseType = '';\r\n        /**\r\n         * Defines whether additional debug information should\r\n         * be shown at the console. Note that in certain browsers\r\n         * the verbosity of the console needs to be explicitly set\r\n         * to include Debug level messages.\r\n         */\r\n        this.showDebugInformation = false;\r\n        /**\r\n         * The redirect uri used when doing silent refresh.\r\n         */\r\n        this.silentRefreshRedirectUri = '';\r\n        this.silentRefreshMessagePrefix = '';\r\n        /**\r\n         * Set this to true to display the iframe used for\r\n         * silent refresh for debugging.\r\n         */\r\n        this.silentRefreshShowIFrame = false;\r\n        /**\r\n         * Timeout for silent refresh.\r\n         * @internal\r\n         * depreacted b/c of typo, see silentRefreshTimeout\r\n         */\r\n        this.siletRefreshTimeout = 1000 * 20;\r\n        /**\r\n         * Timeout for silent refresh.\r\n         */\r\n        this.silentRefreshTimeout = 1000 * 20;\r\n        /**\r\n         * Some auth servers don't allow using password flow\r\n         * w/o a client secret while the standards do not\r\n         * demand for it. In this case, you can set a password\r\n         * here. As this password is exposed to the public\r\n         * it does not bring additional security and is therefore\r\n         * as good as using no password.\r\n         */\r\n        this.dummyClientSecret = '';\r\n        /**\r\n         * Defines whether https is required.\r\n         * The default value is remoteOnly which only allows\r\n         * http for localhost, while every other domains need\r\n         * to be used with https.\r\n         */\r\n        this.requireHttps = 'remoteOnly';\r\n        /**\r\n         * Defines whether every url provided by the discovery\r\n         * document has to start with the issuer's url.\r\n         */\r\n        this.strictDiscoveryDocumentValidation = true;\r\n        /**\r\n         * JSON Web Key Set (https://tools.ietf.org/html/rfc7517)\r\n         * with keys used to validate received id_tokens.\r\n         * This is taken out of the disovery document. Can be set manually too.\r\n         */\r\n        this.jwks = null;\r\n        /**\r\n         * Map with additional query parameter that are appended to\r\n         * the request when initializing implicit flow.\r\n         */\r\n        this.customQueryParams = null;\r\n        this.silentRefreshIFrameName = 'angular-oauth-oidc-silent-refresh-iframe';\r\n        /**\r\n         * Defines when the token_timeout event should be raised.\r\n         * If you set this to the default value 0.75, the event\r\n         * is triggered after 75% of the token's life time.\r\n         */\r\n        this.timeoutFactor = 0.75;\r\n        /**\r\n         * If true, the lib will try to check whether the user\r\n         * is still logged in on a regular basis as described\r\n         * in http://openid.net/specs/openid-connect-session-1_0.html#ChangeNotification\r\n         */\r\n        this.sessionChecksEnabled = false;\r\n        /**\r\n         * Interval in msec for checking the session\r\n         * according to http://openid.net/specs/openid-connect-session-1_0.html#ChangeNotification\r\n         */\r\n        this.sessionCheckIntervall = 3 * 1000;\r\n        /**\r\n         * Url for the iframe used for session checks\r\n         */\r\n        this.sessionCheckIFrameUrl = null;\r\n        /**\r\n         * Name of the iframe to use for session checks\r\n         */\r\n        this.sessionCheckIFrameName = 'angular-oauth-oidc-check-session-iframe';\r\n        /**\r\n         * This property has been introduced to disable at_hash checks\r\n         * and is indented for Identity Provider that does not deliver\r\n         * an at_hash EVEN THOUGH its recommended by the OIDC specs.\r\n         * Of course, when disabling these checks then we are bypassing\r\n         * a security check which means we are more vulnerable.\r\n         */\r\n        this.disableAtHashCheck = false;\r\n        /**\r\n         * Defines wether to check the subject of a refreshed token after silent refresh.\r\n         * Normally, it should be the same as before.\r\n         */\r\n        this.skipSubjectCheck = false;\r\n        this.useIdTokenHintForSilentRefresh = false;\r\n        /**\r\n         * Defined whether to skip the validation of the issuer in the discovery document.\r\n         * Normally, the discovey document's url starts with the url of the issuer.\r\n         */\r\n        this.skipIssuerCheck = false;\r\n        /**\r\n         * final state sent to issuer is built as follows:\r\n         * state = nonce + nonceStateSeparator + additional state\r\n         * Default separator is ';' (encoded %3B).\r\n         * In rare cases, this character might be forbidden or inconvenient to use by the issuer so it can be customized.\r\n         */\r\n        this.nonceStateSeparator = ';';\r\n        /**\r\n         * Set this to true to use HTTP BASIC auth for AJAX calls\r\n         */\r\n        this.useHttpBasicAuth = false;\r\n        /**\r\n         * Decreases the Expiration time of tokens by this number of seconds\r\n         */\r\n        this.decreaseExpirationBySec = 0;\r\n        /**\r\n         * The interceptors waits this time span if there is no token\r\n         */\r\n        this.waitForTokenInMsec = 0;\r\n        /**\r\n         * Code Flow is by defauld used together with PKCI which is also higly recommented.\r\n         * You can disbale it here by setting this flag to true.\r\n         * https://tools.ietf.org/html/rfc7636#section-1.1\r\n         */\r\n        this.disablePKCE = false;\r\n        /**\r\n         * Set this to true to preserve the requested route including query parameters after code flow login.\r\n         * This setting enables deep linking for the code flow.\r\n         */\r\n        this.preserveRequestedRoute = false;\r\n        /**\r\n         * Allows to disable the timer for the id_token used\r\n         * for token refresh\r\n         */\r\n        this.disableIdTokenTimer = false;\r\n        /**\r\n         * Blocks other origins requesting a silent refresh\r\n         */\r\n        this.checkOrigin = false;\r\n        /**\r\n         * This property allows you to override the method that is used to open the login url,\r\n         * allowing a way for implementations to specify their own method of routing to new\r\n         * urls.\r\n         */\r\n        this.openUri = (uri) => {\r\n            location.href = uri;\r\n        };\r\n        if (json) {\r\n            Object.assign(this, json);\r\n        }\r\n    }\r\n}\n\n/**\r\n * This custom encoder allows charactes like +, % and / to be used in passwords\r\n */\r\nclass WebHttpUrlEncodingCodec {\r\n    encodeKey(k) {\r\n        return encodeURIComponent(k);\r\n    }\r\n    encodeValue(v) {\r\n        return encodeURIComponent(v);\r\n    }\r\n    decodeKey(k) {\r\n        return decodeURIComponent(k);\r\n    }\r\n    decodeValue(v) {\r\n        return decodeURIComponent(v);\r\n    }\r\n}\n\n/**\r\n * Interface for Handlers that are hooked in to\r\n * validate tokens.\r\n */\r\nclass ValidationHandler {\r\n}\r\n/**\r\n * This abstract implementation of ValidationHandler already implements\r\n * the method validateAtHash. However, to make use of it,\r\n * you have to override the method calcHash.\r\n */\r\nclass AbstractValidationHandler {\r\n    /**\r\n     * Validates the at_hash in an id_token against the received access_token.\r\n     */\r\n    validateAtHash(params) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let hashAlg = this.inferHashAlgorithm(params.idTokenHeader);\r\n            let tokenHash = yield this.calcHash(params.accessToken, hashAlg); // sha256(accessToken, { asString: true });\r\n            let leftMostHalf = tokenHash.substr(0, tokenHash.length / 2);\r\n            let atHash = base64UrlEncode(leftMostHalf);\r\n            let claimsAtHash = params.idTokenClaims['at_hash'].replace(/=/g, '');\r\n            if (atHash !== claimsAtHash) {\r\n                console.error('exptected at_hash: ' + atHash);\r\n                console.error('actual at_hash: ' + claimsAtHash);\r\n            }\r\n            return atHash === claimsAtHash;\r\n        });\r\n    }\r\n    /**\r\n     * Infers the name of the hash algorithm to use\r\n     * from the alg field of an id_token.\r\n     *\r\n     * @param jwtHeader the id_token's parsed header\r\n     */\r\n    inferHashAlgorithm(jwtHeader) {\r\n        let alg = jwtHeader['alg'];\r\n        if (!alg.match(/^.S[0-9]{3}$/)) {\r\n            throw new Error('Algorithm not supported: ' + alg);\r\n        }\r\n        return 'sha-' + alg.substr(2);\r\n    }\r\n}\n\nclass UrlHelperService {\r\n    getHashFragmentParams(customHashFragment) {\r\n        let hash = customHashFragment || window.location.hash;\r\n        hash = decodeURIComponent(hash);\r\n        if (hash.indexOf('#') !== 0) {\r\n            return {};\r\n        }\r\n        const questionMarkPosition = hash.indexOf('?');\r\n        if (questionMarkPosition > -1) {\r\n            hash = hash.substr(questionMarkPosition + 1);\r\n        }\r\n        else {\r\n            hash = hash.substr(1);\r\n        }\r\n        return this.parseQueryString(hash);\r\n    }\r\n    parseQueryString(queryString) {\r\n        const data = {};\r\n        let pairs, pair, separatorIndex, escapedKey, escapedValue, key, value;\r\n        if (queryString === null) {\r\n            return data;\r\n        }\r\n        pairs = queryString.split('&');\r\n        for (let i = 0; i < pairs.length; i++) {\r\n            pair = pairs[i];\r\n            separatorIndex = pair.indexOf('=');\r\n            if (separatorIndex === -1) {\r\n                escapedKey = pair;\r\n                escapedValue = null;\r\n            }\r\n            else {\r\n                escapedKey = pair.substr(0, separatorIndex);\r\n                escapedValue = pair.substr(separatorIndex + 1);\r\n            }\r\n            key = decodeURIComponent(escapedKey);\r\n            value = decodeURIComponent(escapedValue);\r\n            if (key.substr(0, 1) === '/') {\r\n                key = key.substr(1);\r\n            }\r\n            data[key] = value;\r\n        }\r\n        return data;\r\n    }\r\n}\r\nUrlHelperService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: UrlHelperService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nUrlHelperService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: UrlHelperService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: UrlHelperService, decorators: [{\r\n            type: Injectable\r\n        }] });\n\n// Credits: https://github.com/dchest/fast-sha256-js/tree/master/src\r\n// We add this lib directly b/c the published version of fast-sha256-js\r\n// is commonjs and hence leads to a warning about tree-shakability emitted\r\n// by the Angular CLI\r\n// SHA-256 (+ HMAC and PBKDF2) for JavaScript.\r\n//\r\n// Written in 2014-2016 by Dmitry Chestnykh.\r\n// Public domain, no warranty.\r\n//\r\n// Functions (accept and return Uint8Arrays):\r\n//\r\n//   sha256(message) -> hash\r\n//   sha256.hmac(key, message) -> mac\r\n//   sha256.pbkdf2(password, salt, rounds, dkLen) -> dk\r\n//\r\n//  Classes:\r\n//\r\n//   new sha256.Hash()\r\n//   new sha256.HMAC(key)\r\n//\r\nconst digestLength = 32;\r\nconst blockSize = 64;\r\n// SHA-256 constants\r\nconst K = new Uint32Array([\r\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1,\r\n    0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\r\n    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786,\r\n    0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\r\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,\r\n    0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\r\n    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,\r\n    0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\r\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a,\r\n    0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\r\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,\r\n]);\r\nfunction hashBlocks(w, v, p, pos, len) {\r\n    let a, b, c, d, e, f, g, h, u, i, j, t1, t2;\r\n    while (len >= 64) {\r\n        a = v[0];\r\n        b = v[1];\r\n        c = v[2];\r\n        d = v[3];\r\n        e = v[4];\r\n        f = v[5];\r\n        g = v[6];\r\n        h = v[7];\r\n        for (i = 0; i < 16; i++) {\r\n            j = pos + i * 4;\r\n            w[i] =\r\n                ((p[j] & 0xff) << 24) |\r\n                    ((p[j + 1] & 0xff) << 16) |\r\n                    ((p[j + 2] & 0xff) << 8) |\r\n                    (p[j + 3] & 0xff);\r\n        }\r\n        for (i = 16; i < 64; i++) {\r\n            u = w[i - 2];\r\n            t1 =\r\n                ((u >>> 17) | (u << (32 - 17))) ^\r\n                    ((u >>> 19) | (u << (32 - 19))) ^\r\n                    (u >>> 10);\r\n            u = w[i - 15];\r\n            t2 =\r\n                ((u >>> 7) | (u << (32 - 7))) ^\r\n                    ((u >>> 18) | (u << (32 - 18))) ^\r\n                    (u >>> 3);\r\n            w[i] = ((t1 + w[i - 7]) | 0) + ((t2 + w[i - 16]) | 0);\r\n        }\r\n        for (i = 0; i < 64; i++) {\r\n            t1 =\r\n                ((((((e >>> 6) | (e << (32 - 6))) ^\r\n                    ((e >>> 11) | (e << (32 - 11))) ^\r\n                    ((e >>> 25) | (e << (32 - 25)))) +\r\n                    ((e & f) ^ (~e & g))) |\r\n                    0) +\r\n                    ((h + ((K[i] + w[i]) | 0)) | 0)) |\r\n                    0;\r\n            t2 =\r\n                ((((a >>> 2) | (a << (32 - 2))) ^\r\n                    ((a >>> 13) | (a << (32 - 13))) ^\r\n                    ((a >>> 22) | (a << (32 - 22)))) +\r\n                    ((a & b) ^ (a & c) ^ (b & c))) |\r\n                    0;\r\n            h = g;\r\n            g = f;\r\n            f = e;\r\n            e = (d + t1) | 0;\r\n            d = c;\r\n            c = b;\r\n            b = a;\r\n            a = (t1 + t2) | 0;\r\n        }\r\n        v[0] += a;\r\n        v[1] += b;\r\n        v[2] += c;\r\n        v[3] += d;\r\n        v[4] += e;\r\n        v[5] += f;\r\n        v[6] += g;\r\n        v[7] += h;\r\n        pos += 64;\r\n        len -= 64;\r\n    }\r\n    return pos;\r\n}\r\n// Hash implements SHA256 hash algorithm.\r\nclass Hash {\r\n    constructor() {\r\n        this.digestLength = digestLength;\r\n        this.blockSize = blockSize;\r\n        // Note: Int32Array is used instead of Uint32Array for performance reasons.\r\n        this.state = new Int32Array(8); // hash state\r\n        this.temp = new Int32Array(64); // temporary state\r\n        this.buffer = new Uint8Array(128); // buffer for data to hash\r\n        this.bufferLength = 0; // number of bytes in buffer\r\n        this.bytesHashed = 0; // number of total bytes hashed\r\n        this.finished = false; // indicates whether the hash was finalized\r\n        this.reset();\r\n    }\r\n    // Resets hash state making it possible\r\n    // to re-use this instance to hash other data.\r\n    reset() {\r\n        this.state[0] = 0x6a09e667;\r\n        this.state[1] = 0xbb67ae85;\r\n        this.state[2] = 0x3c6ef372;\r\n        this.state[3] = 0xa54ff53a;\r\n        this.state[4] = 0x510e527f;\r\n        this.state[5] = 0x9b05688c;\r\n        this.state[6] = 0x1f83d9ab;\r\n        this.state[7] = 0x5be0cd19;\r\n        this.bufferLength = 0;\r\n        this.bytesHashed = 0;\r\n        this.finished = false;\r\n        return this;\r\n    }\r\n    // Cleans internal buffers and re-initializes hash state.\r\n    clean() {\r\n        for (let i = 0; i < this.buffer.length; i++) {\r\n            this.buffer[i] = 0;\r\n        }\r\n        for (let i = 0; i < this.temp.length; i++) {\r\n            this.temp[i] = 0;\r\n        }\r\n        this.reset();\r\n    }\r\n    // Updates hash state with the given data.\r\n    //\r\n    // Optionally, length of the data can be specified to hash\r\n    // fewer bytes than data.length.\r\n    //\r\n    // Throws error when trying to update already finalized hash:\r\n    // instance must be reset to use it again.\r\n    update(data, dataLength = data.length) {\r\n        if (this.finished) {\r\n            throw new Error(\"SHA256: can't update because hash was finished.\");\r\n        }\r\n        let dataPos = 0;\r\n        this.bytesHashed += dataLength;\r\n        if (this.bufferLength > 0) {\r\n            while (this.bufferLength < 64 && dataLength > 0) {\r\n                this.buffer[this.bufferLength++] = data[dataPos++];\r\n                dataLength--;\r\n            }\r\n            if (this.bufferLength === 64) {\r\n                hashBlocks(this.temp, this.state, this.buffer, 0, 64);\r\n                this.bufferLength = 0;\r\n            }\r\n        }\r\n        if (dataLength >= 64) {\r\n            dataPos = hashBlocks(this.temp, this.state, data, dataPos, dataLength);\r\n            dataLength %= 64;\r\n        }\r\n        while (dataLength > 0) {\r\n            this.buffer[this.bufferLength++] = data[dataPos++];\r\n            dataLength--;\r\n        }\r\n        return this;\r\n    }\r\n    // Finalizes hash state and puts hash into out.\r\n    //\r\n    // If hash was already finalized, puts the same value.\r\n    finish(out) {\r\n        if (!this.finished) {\r\n            const bytesHashed = this.bytesHashed;\r\n            const left = this.bufferLength;\r\n            const bitLenHi = (bytesHashed / 0x20000000) | 0;\r\n            const bitLenLo = bytesHashed << 3;\r\n            const padLength = bytesHashed % 64 < 56 ? 64 : 128;\r\n            this.buffer[left] = 0x80;\r\n            for (let i = left + 1; i < padLength - 8; i++) {\r\n                this.buffer[i] = 0;\r\n            }\r\n            this.buffer[padLength - 8] = (bitLenHi >>> 24) & 0xff;\r\n            this.buffer[padLength - 7] = (bitLenHi >>> 16) & 0xff;\r\n            this.buffer[padLength - 6] = (bitLenHi >>> 8) & 0xff;\r\n            this.buffer[padLength - 5] = (bitLenHi >>> 0) & 0xff;\r\n            this.buffer[padLength - 4] = (bitLenLo >>> 24) & 0xff;\r\n            this.buffer[padLength - 3] = (bitLenLo >>> 16) & 0xff;\r\n            this.buffer[padLength - 2] = (bitLenLo >>> 8) & 0xff;\r\n            this.buffer[padLength - 1] = (bitLenLo >>> 0) & 0xff;\r\n            hashBlocks(this.temp, this.state, this.buffer, 0, padLength);\r\n            this.finished = true;\r\n        }\r\n        for (let i = 0; i < 8; i++) {\r\n            out[i * 4 + 0] = (this.state[i] >>> 24) & 0xff;\r\n            out[i * 4 + 1] = (this.state[i] >>> 16) & 0xff;\r\n            out[i * 4 + 2] = (this.state[i] >>> 8) & 0xff;\r\n            out[i * 4 + 3] = (this.state[i] >>> 0) & 0xff;\r\n        }\r\n        return this;\r\n    }\r\n    // Returns the final hash digest.\r\n    digest() {\r\n        const out = new Uint8Array(this.digestLength);\r\n        this.finish(out);\r\n        return out;\r\n    }\r\n    // Internal function for use in HMAC for optimization.\r\n    _saveState(out) {\r\n        for (let i = 0; i < this.state.length; i++) {\r\n            out[i] = this.state[i];\r\n        }\r\n    }\r\n    // Internal function for use in HMAC for optimization.\r\n    _restoreState(from, bytesHashed) {\r\n        for (let i = 0; i < this.state.length; i++) {\r\n            this.state[i] = from[i];\r\n        }\r\n        this.bytesHashed = bytesHashed;\r\n        this.finished = false;\r\n        this.bufferLength = 0;\r\n    }\r\n}\r\n// HMAC implements HMAC-SHA256 message authentication algorithm.\r\nclass HMAC {\r\n    constructor(key) {\r\n        this.inner = new Hash();\r\n        this.outer = new Hash();\r\n        this.blockSize = this.inner.blockSize;\r\n        this.digestLength = this.inner.digestLength;\r\n        const pad = new Uint8Array(this.blockSize);\r\n        if (key.length > this.blockSize) {\r\n            new Hash().update(key).finish(pad).clean();\r\n        }\r\n        else {\r\n            for (let i = 0; i < key.length; i++) {\r\n                pad[i] = key[i];\r\n            }\r\n        }\r\n        for (let i = 0; i < pad.length; i++) {\r\n            pad[i] ^= 0x36;\r\n        }\r\n        this.inner.update(pad);\r\n        for (let i = 0; i < pad.length; i++) {\r\n            pad[i] ^= 0x36 ^ 0x5c;\r\n        }\r\n        this.outer.update(pad);\r\n        this.istate = new Uint32Array(8);\r\n        this.ostate = new Uint32Array(8);\r\n        this.inner._saveState(this.istate);\r\n        this.outer._saveState(this.ostate);\r\n        for (let i = 0; i < pad.length; i++) {\r\n            pad[i] = 0;\r\n        }\r\n    }\r\n    // Returns HMAC state to the state initialized with key\r\n    // to make it possible to run HMAC over the other data with the same\r\n    // key without creating a new instance.\r\n    reset() {\r\n        this.inner._restoreState(this.istate, this.inner.blockSize);\r\n        this.outer._restoreState(this.ostate, this.outer.blockSize);\r\n        return this;\r\n    }\r\n    // Cleans HMAC state.\r\n    clean() {\r\n        for (let i = 0; i < this.istate.length; i++) {\r\n            this.ostate[i] = this.istate[i] = 0;\r\n        }\r\n        this.inner.clean();\r\n        this.outer.clean();\r\n    }\r\n    // Updates state with provided data.\r\n    update(data) {\r\n        this.inner.update(data);\r\n        return this;\r\n    }\r\n    // Finalizes HMAC and puts the result in out.\r\n    finish(out) {\r\n        if (this.outer.finished) {\r\n            this.outer.finish(out);\r\n        }\r\n        else {\r\n            this.inner.finish(out);\r\n            this.outer.update(out, this.digestLength).finish(out);\r\n        }\r\n        return this;\r\n    }\r\n    // Returns message authentication code.\r\n    digest() {\r\n        const out = new Uint8Array(this.digestLength);\r\n        this.finish(out);\r\n        return out;\r\n    }\r\n}\r\n// Returns SHA256 hash of data.\r\nfunction hash(data) {\r\n    const h = new Hash().update(data);\r\n    const digest = h.digest();\r\n    h.clean();\r\n    return digest;\r\n}\r\n// Returns HMAC-SHA256 of data under the key.\r\nfunction hmac(key, data) {\r\n    const h = new HMAC(key).update(data);\r\n    const digest = h.digest();\r\n    h.clean();\r\n    return digest;\r\n}\r\n// Fills hkdf buffer like this:\r\n// T(1) = HMAC-Hash(PRK, T(0) | info | 0x01)\r\nfunction fillBuffer(buffer, hmac, info, counter) {\r\n    // Counter is a byte value: check if it overflowed.\r\n    const num = counter[0];\r\n    if (num === 0) {\r\n        throw new Error('hkdf: cannot expand more');\r\n    }\r\n    // Prepare HMAC instance for new data with old key.\r\n    hmac.reset();\r\n    // Hash in previous output if it was generated\r\n    // (i.e. counter is greater than 1).\r\n    if (num > 1) {\r\n        hmac.update(buffer);\r\n    }\r\n    // Hash in info if it exists.\r\n    if (info) {\r\n        hmac.update(info);\r\n    }\r\n    // Hash in the counter.\r\n    hmac.update(counter);\r\n    // Output result to buffer and clean HMAC instance.\r\n    hmac.finish(buffer);\r\n    // Increment counter inside typed array, this works properly.\r\n    counter[0]++;\r\n}\r\nconst hkdfSalt = new Uint8Array(digestLength); // Filled with zeroes.\r\nfunction hkdf(key, salt = hkdfSalt, info, length = 32) {\r\n    const counter = new Uint8Array([1]);\r\n    // HKDF-Extract uses salt as HMAC key, and key as data.\r\n    const okm = hmac(salt, key);\r\n    // Initialize HMAC for expanding with extracted key.\r\n    // Ensure no collisions with `hmac` function.\r\n    const hmac_ = new HMAC(okm);\r\n    // Allocate buffer.\r\n    const buffer = new Uint8Array(hmac_.digestLength);\r\n    let bufpos = buffer.length;\r\n    const out = new Uint8Array(length);\r\n    for (let i = 0; i < length; i++) {\r\n        if (bufpos === buffer.length) {\r\n            fillBuffer(buffer, hmac_, info, counter);\r\n            bufpos = 0;\r\n        }\r\n        out[i] = buffer[bufpos++];\r\n    }\r\n    hmac_.clean();\r\n    buffer.fill(0);\r\n    counter.fill(0);\r\n    return out;\r\n}\r\n// Derives a key from password and salt using PBKDF2-HMAC-SHA256\r\n// with the given number of iterations.\r\n//\r\n// The number of bytes returned is equal to dkLen.\r\n//\r\n// (For better security, avoid dkLen greater than hash length - 32 bytes).\r\nfunction pbkdf2(password, salt, iterations, dkLen) {\r\n    const prf = new HMAC(password);\r\n    const len = prf.digestLength;\r\n    const ctr = new Uint8Array(4);\r\n    const t = new Uint8Array(len);\r\n    const u = new Uint8Array(len);\r\n    const dk = new Uint8Array(dkLen);\r\n    for (let i = 0; i * len < dkLen; i++) {\r\n        let c = i + 1;\r\n        ctr[0] = (c >>> 24) & 0xff;\r\n        ctr[1] = (c >>> 16) & 0xff;\r\n        ctr[2] = (c >>> 8) & 0xff;\r\n        ctr[3] = (c >>> 0) & 0xff;\r\n        prf.reset();\r\n        prf.update(salt);\r\n        prf.update(ctr);\r\n        prf.finish(u);\r\n        for (let j = 0; j < len; j++) {\r\n            t[j] = u[j];\r\n        }\r\n        for (let j = 2; j <= iterations; j++) {\r\n            prf.reset();\r\n            prf.update(u).finish(u);\r\n            for (let k = 0; k < len; k++) {\r\n                t[k] ^= u[k];\r\n            }\r\n        }\r\n        for (let j = 0; j < len && i * len + j < dkLen; j++) {\r\n            dk[i * len + j] = t[j];\r\n        }\r\n    }\r\n    for (let i = 0; i < len; i++) {\r\n        t[i] = u[i] = 0;\r\n    }\r\n    for (let i = 0; i < 4; i++) {\r\n        ctr[i] = 0;\r\n    }\r\n    prf.clean();\r\n    return dk;\r\n}\n\n/**\r\n * Abstraction for crypto algorithms\r\n */\r\nclass HashHandler {\r\n}\r\nfunction decodeUTF8(s) {\r\n    if (typeof s !== 'string')\r\n        throw new TypeError('expected string');\r\n    var i, d = s, b = new Uint8Array(d.length);\r\n    for (i = 0; i < d.length; i++)\r\n        b[i] = d.charCodeAt(i);\r\n    return b;\r\n}\r\nfunction encodeUTF8(arr) {\r\n    var i, s = [];\r\n    for (i = 0; i < arr.length; i++)\r\n        s.push(String.fromCharCode(arr[i]));\r\n    return s.join('');\r\n}\r\nclass DefaultHashHandler {\r\n    calcHash(valueToHash, algorithm) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // const encoder = new TextEncoder();\r\n            // const hashArray = await window.crypto.subtle.digest(algorithm, data);\r\n            // const data = encoder.encode(valueToHash);\r\n            // const fhash = fsha256(valueToHash);\r\n            const candHash = encodeUTF8(hash(decodeUTF8(valueToHash)));\r\n            // const hashArray = (sha256 as any).array(valueToHash);\r\n            // // const hashString = this.toHashString(hashArray);\r\n            // const hashString = this.toHashString2(hashArray);\r\n            // console.debug('hash orig - cand', candHash, hashString);\r\n            // alert(1);\r\n            return candHash;\r\n        });\r\n    }\r\n    toHashString2(byteArray) {\r\n        let result = '';\r\n        for (let e of byteArray) {\r\n            result += String.fromCharCode(e);\r\n        }\r\n        return result;\r\n    }\r\n    toHashString(buffer) {\r\n        const byteArray = new Uint8Array(buffer);\r\n        let result = '';\r\n        for (let e of byteArray) {\r\n            result += String.fromCharCode(e);\r\n        }\r\n        return result;\r\n    }\r\n}\r\nDefaultHashHandler.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: DefaultHashHandler, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nDefaultHashHandler.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: DefaultHashHandler });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: DefaultHashHandler, decorators: [{\r\n            type: Injectable\r\n        }] });\n\n/**\r\n * Service for logging in and logging out with\r\n * OIDC and OAuth2. Supports implicit flow and\r\n * password flow.\r\n */\r\nclass OAuthService extends AuthConfig {\r\n    constructor(ngZone, http, storage, tokenValidationHandler, config, urlHelper, logger, crypto, document, dateTimeService) {\r\n        var _a;\r\n        super();\r\n        this.ngZone = ngZone;\r\n        this.http = http;\r\n        this.config = config;\r\n        this.urlHelper = urlHelper;\r\n        this.logger = logger;\r\n        this.crypto = crypto;\r\n        this.dateTimeService = dateTimeService;\r\n        /**\r\n         * @internal\r\n         * Deprecated:  use property events instead\r\n         */\r\n        this.discoveryDocumentLoaded = false;\r\n        /**\r\n         * The received (passed around) state, when logging\r\n         * in with implicit flow.\r\n         */\r\n        this.state = '';\r\n        this.eventsSubject = new Subject();\r\n        this.discoveryDocumentLoadedSubject = new Subject();\r\n        this.grantTypesSupported = [];\r\n        this.inImplicitFlow = false;\r\n        this.saveNoncesInLocalStorage = false;\r\n        this.debug('angular-oauth2-oidc v10');\r\n        // See https://github.com/manfredsteyer/angular-oauth2-oidc/issues/773 for why this is needed\r\n        this.document = document;\r\n        if (!config) {\r\n            config = {};\r\n        }\r\n        this.discoveryDocumentLoaded$ =\r\n            this.discoveryDocumentLoadedSubject.asObservable();\r\n        this.events = this.eventsSubject.asObservable();\r\n        if (tokenValidationHandler) {\r\n            this.tokenValidationHandler = tokenValidationHandler;\r\n        }\r\n        if (config) {\r\n            this.configure(config);\r\n        }\r\n        try {\r\n            if (storage) {\r\n                this.setStorage(storage);\r\n            }\r\n            else if (typeof sessionStorage !== 'undefined') {\r\n                this.setStorage(sessionStorage);\r\n            }\r\n        }\r\n        catch (e) {\r\n            console.error('No OAuthStorage provided and cannot access default (sessionStorage).' +\r\n                'Consider providing a custom OAuthStorage implementation in your module.', e);\r\n        }\r\n        // in IE, sessionStorage does not always survive a redirect\r\n        if (this.checkLocalStorageAccessable()) {\r\n            const ua = (_a = window === null || window === void 0 ? void 0 : window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent;\r\n            const msie = (ua === null || ua === void 0 ? void 0 : ua.includes('MSIE ')) || (ua === null || ua === void 0 ? void 0 : ua.includes('Trident'));\r\n            if (msie) {\r\n                this.saveNoncesInLocalStorage = true;\r\n            }\r\n        }\r\n        this.setupRefreshTimer();\r\n    }\r\n    checkLocalStorageAccessable() {\r\n        if (typeof window === 'undefined')\r\n            return false;\r\n        const test = 'test';\r\n        try {\r\n            if (typeof window['localStorage'] === 'undefined')\r\n                return false;\r\n            localStorage.setItem(test, test);\r\n            localStorage.removeItem(test);\r\n            return true;\r\n        }\r\n        catch (e) {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Use this method to configure the service\r\n     * @param config the configuration\r\n     */\r\n    configure(config) {\r\n        // For the sake of downward compatibility with\r\n        // original configuration API\r\n        Object.assign(this, new AuthConfig(), config);\r\n        this.config = Object.assign({}, new AuthConfig(), config);\r\n        if (this.sessionChecksEnabled) {\r\n            this.setupSessionCheck();\r\n        }\r\n        this.configChanged();\r\n    }\r\n    configChanged() {\r\n        this.setupRefreshTimer();\r\n    }\r\n    restartSessionChecksIfStillLoggedIn() {\r\n        if (this.hasValidIdToken()) {\r\n            this.initSessionCheck();\r\n        }\r\n    }\r\n    restartRefreshTimerIfStillLoggedIn() {\r\n        this.setupExpirationTimers();\r\n    }\r\n    setupSessionCheck() {\r\n        this.events\r\n            .pipe(filter((e) => e.type === 'token_received'))\r\n            .subscribe((e) => {\r\n            this.initSessionCheck();\r\n        });\r\n    }\r\n    /**\r\n     * Will setup up silent refreshing for when the token is\r\n     * about to expire. When the user is logged out via this.logOut method, the\r\n     * silent refreshing will pause and not refresh the tokens until the user is\r\n     * logged back in via receiving a new token.\r\n     * @param params Additional parameter to pass\r\n     * @param listenTo Setup automatic refresh of a specific token type\r\n     */\r\n    setupAutomaticSilentRefresh(params = {}, listenTo, noPrompt = true) {\r\n        let shouldRunSilentRefresh = true;\r\n        this.clearAutomaticRefreshTimer();\r\n        this.automaticRefreshSubscription = this.events\r\n            .pipe(tap((e) => {\r\n            if (e.type === 'token_received') {\r\n                shouldRunSilentRefresh = true;\r\n            }\r\n            else if (e.type === 'logout') {\r\n                shouldRunSilentRefresh = false;\r\n            }\r\n        }), filter((e) => e.type === 'token_expires' &&\r\n            (listenTo == null || listenTo === 'any' || e.info === listenTo)), debounceTime(1000))\r\n            .subscribe((_) => {\r\n            if (shouldRunSilentRefresh) {\r\n                // this.silentRefresh(params, noPrompt).catch(_ => {\r\n                this.refreshInternal(params, noPrompt).catch((_) => {\r\n                    this.debug('Automatic silent refresh did not work');\r\n                });\r\n            }\r\n        });\r\n        this.restartRefreshTimerIfStillLoggedIn();\r\n    }\r\n    refreshInternal(params, noPrompt) {\r\n        if (!this.useSilentRefresh && this.responseType === 'code') {\r\n            return this.refreshToken();\r\n        }\r\n        else {\r\n            return this.silentRefresh(params, noPrompt);\r\n        }\r\n    }\r\n    /**\r\n     * Convenience method that first calls `loadDiscoveryDocument(...)` and\r\n     * directly chains using the `then(...)` part of the promise to call\r\n     * the `tryLogin(...)` method.\r\n     *\r\n     * @param options LoginOptions to pass through to `tryLogin(...)`\r\n     */\r\n    loadDiscoveryDocumentAndTryLogin(options = null) {\r\n        return this.loadDiscoveryDocument().then((doc) => {\r\n            return this.tryLogin(options);\r\n        });\r\n    }\r\n    /**\r\n     * Convenience method that first calls `loadDiscoveryDocumentAndTryLogin(...)`\r\n     * and if then chains to `initLoginFlow()`, but only if there is no valid\r\n     * IdToken or no valid AccessToken.\r\n     *\r\n     * @param options LoginOptions to pass through to `tryLogin(...)`\r\n     */\r\n    loadDiscoveryDocumentAndLogin(options = null) {\r\n        options = options || {};\r\n        return this.loadDiscoveryDocumentAndTryLogin(options).then((_) => {\r\n            if (!this.hasValidIdToken() || !this.hasValidAccessToken()) {\r\n                const state = typeof options.state === 'string' ? options.state : '';\r\n                this.initLoginFlow(state);\r\n                return false;\r\n            }\r\n            else {\r\n                return true;\r\n            }\r\n        });\r\n    }\r\n    debug(...args) {\r\n        if (this.showDebugInformation) {\r\n            this.logger.debug.apply(this.logger, args);\r\n        }\r\n    }\r\n    validateUrlFromDiscoveryDocument(url) {\r\n        const errors = [];\r\n        const httpsCheck = this.validateUrlForHttps(url);\r\n        const issuerCheck = this.validateUrlAgainstIssuer(url);\r\n        if (!httpsCheck) {\r\n            errors.push('https for all urls required. Also for urls received by discovery.');\r\n        }\r\n        if (!issuerCheck) {\r\n            errors.push('Every url in discovery document has to start with the issuer url.' +\r\n                'Also see property strictDiscoveryDocumentValidation.');\r\n        }\r\n        return errors;\r\n    }\r\n    validateUrlForHttps(url) {\r\n        if (!url) {\r\n            return true;\r\n        }\r\n        const lcUrl = url.toLowerCase();\r\n        if (this.requireHttps === false) {\r\n            return true;\r\n        }\r\n        if ((lcUrl.match(/^http:\\/\\/localhost($|[:\\/])/) ||\r\n            lcUrl.match(/^http:\\/\\/localhost($|[:\\/])/)) &&\r\n            this.requireHttps === 'remoteOnly') {\r\n            return true;\r\n        }\r\n        return lcUrl.startsWith('https://');\r\n    }\r\n    assertUrlNotNullAndCorrectProtocol(url, description) {\r\n        if (!url) {\r\n            throw new Error(`'${description}' should not be null`);\r\n        }\r\n        if (!this.validateUrlForHttps(url)) {\r\n            throw new Error(`'${description}' must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).`);\r\n        }\r\n    }\r\n    validateUrlAgainstIssuer(url) {\r\n        if (!this.strictDiscoveryDocumentValidation) {\r\n            return true;\r\n        }\r\n        if (!url) {\r\n            return true;\r\n        }\r\n        return url.toLowerCase().startsWith(this.issuer.toLowerCase());\r\n    }\r\n    setupRefreshTimer() {\r\n        if (typeof window === 'undefined') {\r\n            this.debug('timer not supported on this plattform');\r\n            return;\r\n        }\r\n        if (this.hasValidIdToken() || this.hasValidAccessToken()) {\r\n            this.clearAccessTokenTimer();\r\n            this.clearIdTokenTimer();\r\n            this.setupExpirationTimers();\r\n        }\r\n        if (this.tokenReceivedSubscription)\r\n            this.tokenReceivedSubscription.unsubscribe();\r\n        this.tokenReceivedSubscription = this.events\r\n            .pipe(filter((e) => e.type === 'token_received'))\r\n            .subscribe((_) => {\r\n            this.clearAccessTokenTimer();\r\n            this.clearIdTokenTimer();\r\n            this.setupExpirationTimers();\r\n        });\r\n    }\r\n    setupExpirationTimers() {\r\n        if (this.hasValidAccessToken()) {\r\n            this.setupAccessTokenTimer();\r\n        }\r\n        if (!this.disableIdTokenTimer && this.hasValidIdToken()) {\r\n            this.setupIdTokenTimer();\r\n        }\r\n    }\r\n    setupAccessTokenTimer() {\r\n        const expiration = this.getAccessTokenExpiration();\r\n        const storedAt = this.getAccessTokenStoredAt();\r\n        const timeout = this.calcTimeout(storedAt, expiration);\r\n        this.ngZone.runOutsideAngular(() => {\r\n            this.accessTokenTimeoutSubscription = of(new OAuthInfoEvent('token_expires', 'access_token'))\r\n                .pipe(delay(timeout))\r\n                .subscribe((e) => {\r\n                this.ngZone.run(() => {\r\n                    this.eventsSubject.next(e);\r\n                });\r\n            });\r\n        });\r\n    }\r\n    setupIdTokenTimer() {\r\n        const expiration = this.getIdTokenExpiration();\r\n        const storedAt = this.getIdTokenStoredAt();\r\n        const timeout = this.calcTimeout(storedAt, expiration);\r\n        this.ngZone.runOutsideAngular(() => {\r\n            this.idTokenTimeoutSubscription = of(new OAuthInfoEvent('token_expires', 'id_token'))\r\n                .pipe(delay(timeout))\r\n                .subscribe((e) => {\r\n                this.ngZone.run(() => {\r\n                    this.eventsSubject.next(e);\r\n                });\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Stops timers for automatic refresh.\r\n     * To restart it, call setupAutomaticSilentRefresh again.\r\n     */\r\n    stopAutomaticRefresh() {\r\n        this.clearAccessTokenTimer();\r\n        this.clearIdTokenTimer();\r\n        this.clearAutomaticRefreshTimer();\r\n    }\r\n    clearAccessTokenTimer() {\r\n        if (this.accessTokenTimeoutSubscription) {\r\n            this.accessTokenTimeoutSubscription.unsubscribe();\r\n        }\r\n    }\r\n    clearIdTokenTimer() {\r\n        if (this.idTokenTimeoutSubscription) {\r\n            this.idTokenTimeoutSubscription.unsubscribe();\r\n        }\r\n    }\r\n    clearAutomaticRefreshTimer() {\r\n        if (this.automaticRefreshSubscription) {\r\n            this.automaticRefreshSubscription.unsubscribe();\r\n        }\r\n    }\r\n    calcTimeout(storedAt, expiration) {\r\n        const now = this.dateTimeService.now();\r\n        const delta = (expiration - storedAt) * this.timeoutFactor - (now - storedAt);\r\n        const duration = Math.max(0, delta);\r\n        const maxTimeoutValue = 2147483647;\r\n        return duration > maxTimeoutValue ? maxTimeoutValue : duration;\r\n    }\r\n    /**\r\n     * DEPRECATED. Use a provider for OAuthStorage instead:\r\n     *\r\n     * { provide: OAuthStorage, useFactory: oAuthStorageFactory }\r\n     * export function oAuthStorageFactory(): OAuthStorage { return localStorage; }\r\n     * Sets a custom storage used to store the received\r\n     * tokens on client side. By default, the browser's\r\n     * sessionStorage is used.\r\n     * @ignore\r\n     *\r\n     * @param storage\r\n     */\r\n    setStorage(storage) {\r\n        this._storage = storage;\r\n        this.configChanged();\r\n    }\r\n    /**\r\n     * Loads the discovery document to configure most\r\n     * properties of this service. The url of the discovery\r\n     * document is infered from the issuer's url according\r\n     * to the OpenId Connect spec. To use another url you\r\n     * can pass it to to optional parameter fullUrl.\r\n     *\r\n     * @param fullUrl\r\n     */\r\n    loadDiscoveryDocument(fullUrl = null) {\r\n        return new Promise((resolve, reject) => {\r\n            if (!fullUrl) {\r\n                fullUrl = this.issuer || '';\r\n                if (!fullUrl.endsWith('/')) {\r\n                    fullUrl += '/';\r\n                }\r\n                fullUrl += '.well-known/openid-configuration';\r\n            }\r\n            if (!this.validateUrlForHttps(fullUrl)) {\r\n                reject(\"issuer  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\");\r\n                return;\r\n            }\r\n            this.http.get(fullUrl).subscribe((doc) => {\r\n                if (!this.validateDiscoveryDocument(doc)) {\r\n                    this.eventsSubject.next(new OAuthErrorEvent('discovery_document_validation_error', null));\r\n                    reject('discovery_document_validation_error');\r\n                    return;\r\n                }\r\n                this.loginUrl = doc.authorization_endpoint;\r\n                this.logoutUrl = doc.end_session_endpoint || this.logoutUrl;\r\n                this.grantTypesSupported = doc.grant_types_supported;\r\n                this.issuer = doc.issuer;\r\n                this.tokenEndpoint = doc.token_endpoint;\r\n                this.userinfoEndpoint =\r\n                    doc.userinfo_endpoint || this.userinfoEndpoint;\r\n                this.jwksUri = doc.jwks_uri;\r\n                this.sessionCheckIFrameUrl =\r\n                    doc.check_session_iframe || this.sessionCheckIFrameUrl;\r\n                this.discoveryDocumentLoaded = true;\r\n                this.discoveryDocumentLoadedSubject.next(doc);\r\n                this.revocationEndpoint =\r\n                    doc.revocation_endpoint || this.revocationEndpoint;\r\n                if (this.sessionChecksEnabled) {\r\n                    this.restartSessionChecksIfStillLoggedIn();\r\n                }\r\n                this.loadJwks()\r\n                    .then((jwks) => {\r\n                    const result = {\r\n                        discoveryDocument: doc,\r\n                        jwks: jwks,\r\n                    };\r\n                    const event = new OAuthSuccessEvent('discovery_document_loaded', result);\r\n                    this.eventsSubject.next(event);\r\n                    resolve(event);\r\n                    return;\r\n                })\r\n                    .catch((err) => {\r\n                    this.eventsSubject.next(new OAuthErrorEvent('discovery_document_load_error', err));\r\n                    reject(err);\r\n                    return;\r\n                });\r\n            }, (err) => {\r\n                this.logger.error('error loading discovery document', err);\r\n                this.eventsSubject.next(new OAuthErrorEvent('discovery_document_load_error', err));\r\n                reject(err);\r\n            });\r\n        });\r\n    }\r\n    loadJwks() {\r\n        return new Promise((resolve, reject) => {\r\n            if (this.jwksUri) {\r\n                this.http.get(this.jwksUri).subscribe((jwks) => {\r\n                    this.jwks = jwks;\r\n                    // this.eventsSubject.next(\r\n                    //   new OAuthSuccessEvent('discovery_document_loaded')\r\n                    // );\r\n                    resolve(jwks);\r\n                }, (err) => {\r\n                    this.logger.error('error loading jwks', err);\r\n                    this.eventsSubject.next(new OAuthErrorEvent('jwks_load_error', err));\r\n                    reject(err);\r\n                });\r\n            }\r\n            else {\r\n                resolve(null);\r\n            }\r\n        });\r\n    }\r\n    validateDiscoveryDocument(doc) {\r\n        let errors;\r\n        if (!this.skipIssuerCheck && doc.issuer !== this.issuer) {\r\n            this.logger.error('invalid issuer in discovery document', 'expected: ' + this.issuer, 'current: ' + doc.issuer);\r\n            return false;\r\n        }\r\n        errors = this.validateUrlFromDiscoveryDocument(doc.authorization_endpoint);\r\n        if (errors.length > 0) {\r\n            this.logger.error('error validating authorization_endpoint in discovery document', errors);\r\n            return false;\r\n        }\r\n        errors = this.validateUrlFromDiscoveryDocument(doc.end_session_endpoint);\r\n        if (errors.length > 0) {\r\n            this.logger.error('error validating end_session_endpoint in discovery document', errors);\r\n            return false;\r\n        }\r\n        errors = this.validateUrlFromDiscoveryDocument(doc.token_endpoint);\r\n        if (errors.length > 0) {\r\n            this.logger.error('error validating token_endpoint in discovery document', errors);\r\n        }\r\n        errors = this.validateUrlFromDiscoveryDocument(doc.revocation_endpoint);\r\n        if (errors.length > 0) {\r\n            this.logger.error('error validating revocation_endpoint in discovery document', errors);\r\n        }\r\n        errors = this.validateUrlFromDiscoveryDocument(doc.userinfo_endpoint);\r\n        if (errors.length > 0) {\r\n            this.logger.error('error validating userinfo_endpoint in discovery document', errors);\r\n            return false;\r\n        }\r\n        errors = this.validateUrlFromDiscoveryDocument(doc.jwks_uri);\r\n        if (errors.length > 0) {\r\n            this.logger.error('error validating jwks_uri in discovery document', errors);\r\n            return false;\r\n        }\r\n        if (this.sessionChecksEnabled && !doc.check_session_iframe) {\r\n            this.logger.warn('sessionChecksEnabled is activated but discovery document' +\r\n                ' does not contain a check_session_iframe field');\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Uses password flow to exchange userName and password for an\r\n     * access_token. After receiving the access_token, this method\r\n     * uses it to query the userinfo endpoint in order to get information\r\n     * about the user in question.\r\n     *\r\n     * When using this, make sure that the property oidc is set to false.\r\n     * Otherwise stricter validations take place that make this operation\r\n     * fail.\r\n     *\r\n     * @param userName\r\n     * @param password\r\n     * @param headers Optional additional http-headers.\r\n     */\r\n    fetchTokenUsingPasswordFlowAndLoadUserProfile(userName, password, headers = new HttpHeaders()) {\r\n        return this.fetchTokenUsingPasswordFlow(userName, password, headers).then(() => this.loadUserProfile());\r\n    }\r\n    /**\r\n     * Loads the user profile by accessing the user info endpoint defined by OpenId Connect.\r\n     *\r\n     * When using this with OAuth2 password flow, make sure that the property oidc is set to false.\r\n     * Otherwise stricter validations take place that make this operation fail.\r\n     */\r\n    loadUserProfile() {\r\n        if (!this.hasValidAccessToken()) {\r\n            throw new Error('Can not load User Profile without access_token');\r\n        }\r\n        if (!this.validateUrlForHttps(this.userinfoEndpoint)) {\r\n            throw new Error(\"userinfoEndpoint must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\");\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            const headers = new HttpHeaders().set('Authorization', 'Bearer ' + this.getAccessToken());\r\n            this.http\r\n                .get(this.userinfoEndpoint, {\r\n                headers,\r\n                observe: 'response',\r\n                responseType: 'text',\r\n            })\r\n                .subscribe((response) => {\r\n                this.debug('userinfo received', JSON.stringify(response));\r\n                if (response.headers\r\n                    .get('content-type')\r\n                    .startsWith('application/json')) {\r\n                    let info = JSON.parse(response.body);\r\n                    const existingClaims = this.getIdentityClaims() || {};\r\n                    if (!this.skipSubjectCheck) {\r\n                        if (this.oidc &&\r\n                            (!existingClaims['sub'] || info.sub !== existingClaims['sub'])) {\r\n                            const err = 'if property oidc is true, the received user-id (sub) has to be the user-id ' +\r\n                                'of the user that has logged in with oidc.\\n' +\r\n                                'if you are not using oidc but just oauth2 password flow set oidc to false';\r\n                            reject(err);\r\n                            return;\r\n                        }\r\n                    }\r\n                    info = Object.assign({}, existingClaims, info);\r\n                    this._storage.setItem('id_token_claims_obj', JSON.stringify(info));\r\n                    this.eventsSubject.next(new OAuthSuccessEvent('user_profile_loaded'));\r\n                    resolve({ info });\r\n                }\r\n                else {\r\n                    this.debug('userinfo is not JSON, treating it as JWE/JWS');\r\n                    this.eventsSubject.next(new OAuthSuccessEvent('user_profile_loaded'));\r\n                    resolve(JSON.parse(response.body));\r\n                }\r\n            }, (err) => {\r\n                this.logger.error('error loading user info', err);\r\n                this.eventsSubject.next(new OAuthErrorEvent('user_profile_load_error', err));\r\n                reject(err);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Uses password flow to exchange userName and password for an access_token.\r\n     * @param userName\r\n     * @param password\r\n     * @param headers Optional additional http-headers.\r\n     */\r\n    fetchTokenUsingPasswordFlow(userName, password, headers = new HttpHeaders()) {\r\n        const parameters = {\r\n            username: userName,\r\n            password: password,\r\n        };\r\n        return this.fetchTokenUsingGrant('password', parameters, headers);\r\n    }\r\n    /**\r\n     * Uses a custom grant type to retrieve tokens.\r\n     * @param grantType Grant type.\r\n     * @param parameters Parameters to pass.\r\n     * @param headers Optional additional HTTP headers.\r\n     */\r\n    fetchTokenUsingGrant(grantType, parameters, headers = new HttpHeaders()) {\r\n        this.assertUrlNotNullAndCorrectProtocol(this.tokenEndpoint, 'tokenEndpoint');\r\n        /**\r\n         * A `HttpParameterCodec` that uses `encodeURIComponent` and `decodeURIComponent` to\r\n         * serialize and parse URL parameter keys and values.\r\n         *\r\n         * @stable\r\n         */\r\n        let params = new HttpParams({ encoder: new WebHttpUrlEncodingCodec() })\r\n            .set('grant_type', grantType)\r\n            .set('scope', this.scope);\r\n        if (this.useHttpBasicAuth) {\r\n            const header = btoa(`${this.clientId}:${this.dummyClientSecret}`);\r\n            headers = headers.set('Authorization', 'Basic ' + header);\r\n        }\r\n        if (!this.useHttpBasicAuth) {\r\n            params = params.set('client_id', this.clientId);\r\n        }\r\n        if (!this.useHttpBasicAuth && this.dummyClientSecret) {\r\n            params = params.set('client_secret', this.dummyClientSecret);\r\n        }\r\n        if (this.customQueryParams) {\r\n            for (const key of Object.getOwnPropertyNames(this.customQueryParams)) {\r\n                params = params.set(key, this.customQueryParams[key]);\r\n            }\r\n        }\r\n        // set explicit parameters last, to allow overwriting\r\n        for (const key of Object.keys(parameters)) {\r\n            params = params.set(key, parameters[key]);\r\n        }\r\n        headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\r\n        return new Promise((resolve, reject) => {\r\n            this.http\r\n                .post(this.tokenEndpoint, params, { headers })\r\n                .subscribe((tokenResponse) => {\r\n                this.debug('tokenResponse', tokenResponse);\r\n                this.storeAccessTokenResponse(tokenResponse.access_token, tokenResponse.refresh_token, tokenResponse.expires_in ||\r\n                    this.fallbackAccessTokenExpirationTimeInSec, tokenResponse.scope, this.extractRecognizedCustomParameters(tokenResponse));\r\n                if (this.oidc && tokenResponse.id_token) {\r\n                    this.processIdToken(tokenResponse.id_token, tokenResponse.access_token).then((result) => {\r\n                        this.storeIdToken(result);\r\n                        resolve(tokenResponse);\r\n                    });\r\n                }\r\n                this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\r\n                resolve(tokenResponse);\r\n            }, (err) => {\r\n                this.logger.error('Error performing ${grantType} flow', err);\r\n                this.eventsSubject.next(new OAuthErrorEvent('token_error', err));\r\n                reject(err);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Refreshes the token using a refresh_token.\r\n     * This does not work for implicit flow, b/c\r\n     * there is no refresh_token in this flow.\r\n     * A solution for this is provided by the\r\n     * method silentRefresh.\r\n     */\r\n    refreshToken() {\r\n        this.assertUrlNotNullAndCorrectProtocol(this.tokenEndpoint, 'tokenEndpoint');\r\n        return new Promise((resolve, reject) => {\r\n            let params = new HttpParams({ encoder: new WebHttpUrlEncodingCodec() })\r\n                .set('grant_type', 'refresh_token')\r\n                .set('scope', this.scope)\r\n                .set('refresh_token', this._storage.getItem('refresh_token'));\r\n            let headers = new HttpHeaders().set('Content-Type', 'application/x-www-form-urlencoded');\r\n            if (this.useHttpBasicAuth) {\r\n                const header = btoa(`${this.clientId}:${this.dummyClientSecret}`);\r\n                headers = headers.set('Authorization', 'Basic ' + header);\r\n            }\r\n            if (!this.useHttpBasicAuth) {\r\n                params = params.set('client_id', this.clientId);\r\n            }\r\n            if (!this.useHttpBasicAuth && this.dummyClientSecret) {\r\n                params = params.set('client_secret', this.dummyClientSecret);\r\n            }\r\n            if (this.customQueryParams) {\r\n                for (const key of Object.getOwnPropertyNames(this.customQueryParams)) {\r\n                    params = params.set(key, this.customQueryParams[key]);\r\n                }\r\n            }\r\n            this.http\r\n                .post(this.tokenEndpoint, params, { headers })\r\n                .pipe(switchMap((tokenResponse) => {\r\n                if (this.oidc && tokenResponse.id_token) {\r\n                    return from(this.processIdToken(tokenResponse.id_token, tokenResponse.access_token, true)).pipe(tap((result) => this.storeIdToken(result)), map((_) => tokenResponse));\r\n                }\r\n                else {\r\n                    return of(tokenResponse);\r\n                }\r\n            }))\r\n                .subscribe((tokenResponse) => {\r\n                this.debug('refresh tokenResponse', tokenResponse);\r\n                this.storeAccessTokenResponse(tokenResponse.access_token, tokenResponse.refresh_token, tokenResponse.expires_in ||\r\n                    this.fallbackAccessTokenExpirationTimeInSec, tokenResponse.scope, this.extractRecognizedCustomParameters(tokenResponse));\r\n                this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\r\n                this.eventsSubject.next(new OAuthSuccessEvent('token_refreshed'));\r\n                resolve(tokenResponse);\r\n            }, (err) => {\r\n                this.logger.error('Error refreshing token', err);\r\n                this.eventsSubject.next(new OAuthErrorEvent('token_refresh_error', err));\r\n                reject(err);\r\n            });\r\n        });\r\n    }\r\n    removeSilentRefreshEventListener() {\r\n        if (this.silentRefreshPostMessageEventListener) {\r\n            window.removeEventListener('message', this.silentRefreshPostMessageEventListener);\r\n            this.silentRefreshPostMessageEventListener = null;\r\n        }\r\n    }\r\n    setupSilentRefreshEventListener() {\r\n        this.removeSilentRefreshEventListener();\r\n        this.silentRefreshPostMessageEventListener = (e) => {\r\n            const message = this.processMessageEventMessage(e);\r\n            if (this.checkOrigin && e.origin !== location.origin) {\r\n                console.error('wrong origin requested silent refresh!');\r\n            }\r\n            this.tryLogin({\r\n                customHashFragment: message,\r\n                preventClearHashAfterLogin: true,\r\n                customRedirectUri: this.silentRefreshRedirectUri || this.redirectUri,\r\n            }).catch((err) => this.debug('tryLogin during silent refresh failed', err));\r\n        };\r\n        window.addEventListener('message', this.silentRefreshPostMessageEventListener);\r\n    }\r\n    /**\r\n     * Performs a silent refresh for implicit flow.\r\n     * Use this method to get new tokens when/before\r\n     * the existing tokens expire.\r\n     */\r\n    silentRefresh(params = {}, noPrompt = true) {\r\n        const claims = this.getIdentityClaims() || {};\r\n        if (this.useIdTokenHintForSilentRefresh && this.hasValidIdToken()) {\r\n            params['id_token_hint'] = this.getIdToken();\r\n        }\r\n        if (!this.validateUrlForHttps(this.loginUrl)) {\r\n            throw new Error(\"loginUrl  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\");\r\n        }\r\n        if (typeof this.document === 'undefined') {\r\n            throw new Error('silent refresh is not supported on this platform');\r\n        }\r\n        const existingIframe = this.document.getElementById(this.silentRefreshIFrameName);\r\n        if (existingIframe) {\r\n            this.document.body.removeChild(existingIframe);\r\n        }\r\n        this.silentRefreshSubject = claims['sub'];\r\n        const iframe = this.document.createElement('iframe');\r\n        iframe.id = this.silentRefreshIFrameName;\r\n        this.setupSilentRefreshEventListener();\r\n        const redirectUri = this.silentRefreshRedirectUri || this.redirectUri;\r\n        this.createLoginUrl(null, null, redirectUri, noPrompt, params).then((url) => {\r\n            iframe.setAttribute('src', url);\r\n            if (!this.silentRefreshShowIFrame) {\r\n                iframe.style['display'] = 'none';\r\n            }\r\n            this.document.body.appendChild(iframe);\r\n        });\r\n        const errors = this.events.pipe(filter((e) => e instanceof OAuthErrorEvent), first());\r\n        const success = this.events.pipe(filter((e) => e.type === 'token_received'), first());\r\n        const timeout = of(new OAuthErrorEvent('silent_refresh_timeout', null)).pipe(delay(this.silentRefreshTimeout));\r\n        return race([errors, success, timeout])\r\n            .pipe(map((e) => {\r\n            if (e instanceof OAuthErrorEvent) {\r\n                if (e.type === 'silent_refresh_timeout') {\r\n                    this.eventsSubject.next(e);\r\n                }\r\n                else {\r\n                    e = new OAuthErrorEvent('silent_refresh_error', e);\r\n                    this.eventsSubject.next(e);\r\n                }\r\n                throw e;\r\n            }\r\n            else if (e.type === 'token_received') {\r\n                e = new OAuthSuccessEvent('silently_refreshed');\r\n                this.eventsSubject.next(e);\r\n            }\r\n            return e;\r\n        }))\r\n            .toPromise();\r\n    }\r\n    /**\r\n     * This method exists for backwards compatibility.\r\n     * {@link OAuthService#initLoginFlowInPopup} handles both code\r\n     * and implicit flows.\r\n     */\r\n    initImplicitFlowInPopup(options) {\r\n        return this.initLoginFlowInPopup(options);\r\n    }\r\n    initLoginFlowInPopup(options) {\r\n        options = options || {};\r\n        return this.createLoginUrl(null, null, this.silentRefreshRedirectUri, false, {\r\n            display: 'popup',\r\n        }).then((url) => {\r\n            return new Promise((resolve, reject) => {\r\n                /**\r\n                 * Error handling section\r\n                 */\r\n                const checkForPopupClosedInterval = 500;\r\n                let windowRef = null;\r\n                // If we got no window reference we open a window\r\n                // else we are using the window already opened\r\n                if (!options.windowRef) {\r\n                    windowRef = window.open(url, 'ngx-oauth2-oidc-login', this.calculatePopupFeatures(options));\r\n                }\r\n                else if (options.windowRef && !options.windowRef.closed) {\r\n                    windowRef = options.windowRef;\r\n                    windowRef.location.href = url;\r\n                }\r\n                let checkForPopupClosedTimer;\r\n                const tryLogin = (hash) => {\r\n                    this.tryLogin({\r\n                        customHashFragment: hash,\r\n                        preventClearHashAfterLogin: true,\r\n                        customRedirectUri: this.silentRefreshRedirectUri,\r\n                    }).then(() => {\r\n                        cleanup();\r\n                        resolve(true);\r\n                    }, (err) => {\r\n                        cleanup();\r\n                        reject(err);\r\n                    });\r\n                };\r\n                const checkForPopupClosed = () => {\r\n                    if (!windowRef || windowRef.closed) {\r\n                        cleanup();\r\n                        reject(new OAuthErrorEvent('popup_closed', {}));\r\n                    }\r\n                };\r\n                if (!windowRef) {\r\n                    reject(new OAuthErrorEvent('popup_blocked', {}));\r\n                }\r\n                else {\r\n                    checkForPopupClosedTimer = window.setInterval(checkForPopupClosed, checkForPopupClosedInterval);\r\n                }\r\n                const cleanup = () => {\r\n                    window.clearInterval(checkForPopupClosedTimer);\r\n                    window.removeEventListener('storage', storageListener);\r\n                    window.removeEventListener('message', listener);\r\n                    if (windowRef !== null) {\r\n                        windowRef.close();\r\n                    }\r\n                    windowRef = null;\r\n                };\r\n                const listener = (e) => {\r\n                    const message = this.processMessageEventMessage(e);\r\n                    if (message && message !== null) {\r\n                        window.removeEventListener('storage', storageListener);\r\n                        tryLogin(message);\r\n                    }\r\n                    else {\r\n                        console.log('false event firing');\r\n                    }\r\n                };\r\n                const storageListener = (event) => {\r\n                    if (event.key === 'auth_hash') {\r\n                        window.removeEventListener('message', listener);\r\n                        tryLogin(event.newValue);\r\n                    }\r\n                };\r\n                window.addEventListener('message', listener);\r\n                window.addEventListener('storage', storageListener);\r\n            });\r\n        });\r\n    }\r\n    calculatePopupFeatures(options) {\r\n        // Specify an static height and width and calculate centered position\r\n        const height = options.height || 470;\r\n        const width = options.width || 500;\r\n        const left = window.screenLeft + (window.outerWidth - width) / 2;\r\n        const top = window.screenTop + (window.outerHeight - height) / 2;\r\n        return `location=no,toolbar=no,width=${width},height=${height},top=${top},left=${left}`;\r\n    }\r\n    processMessageEventMessage(e) {\r\n        let expectedPrefix = '#';\r\n        if (this.silentRefreshMessagePrefix) {\r\n            expectedPrefix += this.silentRefreshMessagePrefix;\r\n        }\r\n        if (!e || !e.data || typeof e.data !== 'string') {\r\n            return;\r\n        }\r\n        const prefixedMessage = e.data;\r\n        if (!prefixedMessage.startsWith(expectedPrefix)) {\r\n            return;\r\n        }\r\n        return '#' + prefixedMessage.substr(expectedPrefix.length);\r\n    }\r\n    canPerformSessionCheck() {\r\n        if (!this.sessionChecksEnabled) {\r\n            return false;\r\n        }\r\n        if (!this.sessionCheckIFrameUrl) {\r\n            console.warn('sessionChecksEnabled is activated but there is no sessionCheckIFrameUrl');\r\n            return false;\r\n        }\r\n        const sessionState = this.getSessionState();\r\n        if (!sessionState) {\r\n            console.warn('sessionChecksEnabled is activated but there is no session_state');\r\n            return false;\r\n        }\r\n        if (typeof this.document === 'undefined') {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    setupSessionCheckEventListener() {\r\n        this.removeSessionCheckEventListener();\r\n        this.sessionCheckEventListener = (e) => {\r\n            const origin = e.origin.toLowerCase();\r\n            const issuer = this.issuer.toLowerCase();\r\n            this.debug('sessionCheckEventListener');\r\n            if (!issuer.startsWith(origin)) {\r\n                this.debug('sessionCheckEventListener', 'wrong origin', origin, 'expected', issuer, 'event', e);\r\n                return;\r\n            }\r\n            // only run in Angular zone if it is 'changed' or 'error'\r\n            switch (e.data) {\r\n                case 'unchanged':\r\n                    this.ngZone.run(() => {\r\n                        this.handleSessionUnchanged();\r\n                    });\r\n                    break;\r\n                case 'changed':\r\n                    this.ngZone.run(() => {\r\n                        this.handleSessionChange();\r\n                    });\r\n                    break;\r\n                case 'error':\r\n                    this.ngZone.run(() => {\r\n                        this.handleSessionError();\r\n                    });\r\n                    break;\r\n            }\r\n            this.debug('got info from session check inframe', e);\r\n        };\r\n        // prevent Angular from refreshing the view on every message (runs in intervals)\r\n        this.ngZone.runOutsideAngular(() => {\r\n            window.addEventListener('message', this.sessionCheckEventListener);\r\n        });\r\n    }\r\n    handleSessionUnchanged() {\r\n        this.debug('session check', 'session unchanged');\r\n        this.eventsSubject.next(new OAuthInfoEvent('session_unchanged'));\r\n    }\r\n    handleSessionChange() {\r\n        this.eventsSubject.next(new OAuthInfoEvent('session_changed'));\r\n        this.stopSessionCheckTimer();\r\n        if (!this.useSilentRefresh && this.responseType === 'code') {\r\n            this.refreshToken()\r\n                .then((_) => {\r\n                this.debug('token refresh after session change worked');\r\n            })\r\n                .catch((_) => {\r\n                this.debug('token refresh did not work after session changed');\r\n                this.eventsSubject.next(new OAuthInfoEvent('session_terminated'));\r\n                this.logOut(true);\r\n            });\r\n        }\r\n        else if (this.silentRefreshRedirectUri) {\r\n            this.silentRefresh().catch((_) => this.debug('silent refresh failed after session changed'));\r\n            this.waitForSilentRefreshAfterSessionChange();\r\n        }\r\n        else {\r\n            this.eventsSubject.next(new OAuthInfoEvent('session_terminated'));\r\n            this.logOut(true);\r\n        }\r\n    }\r\n    waitForSilentRefreshAfterSessionChange() {\r\n        this.events\r\n            .pipe(filter((e) => e.type === 'silently_refreshed' ||\r\n            e.type === 'silent_refresh_timeout' ||\r\n            e.type === 'silent_refresh_error'), first())\r\n            .subscribe((e) => {\r\n            if (e.type !== 'silently_refreshed') {\r\n                this.debug('silent refresh did not work after session changed');\r\n                this.eventsSubject.next(new OAuthInfoEvent('session_terminated'));\r\n                this.logOut(true);\r\n            }\r\n        });\r\n    }\r\n    handleSessionError() {\r\n        this.stopSessionCheckTimer();\r\n        this.eventsSubject.next(new OAuthInfoEvent('session_error'));\r\n    }\r\n    removeSessionCheckEventListener() {\r\n        if (this.sessionCheckEventListener) {\r\n            window.removeEventListener('message', this.sessionCheckEventListener);\r\n            this.sessionCheckEventListener = null;\r\n        }\r\n    }\r\n    initSessionCheck() {\r\n        if (!this.canPerformSessionCheck()) {\r\n            return;\r\n        }\r\n        const existingIframe = this.document.getElementById(this.sessionCheckIFrameName);\r\n        if (existingIframe) {\r\n            this.document.body.removeChild(existingIframe);\r\n        }\r\n        const iframe = this.document.createElement('iframe');\r\n        iframe.id = this.sessionCheckIFrameName;\r\n        this.setupSessionCheckEventListener();\r\n        const url = this.sessionCheckIFrameUrl;\r\n        iframe.setAttribute('src', url);\r\n        iframe.style.display = 'none';\r\n        this.document.body.appendChild(iframe);\r\n        this.startSessionCheckTimer();\r\n    }\r\n    startSessionCheckTimer() {\r\n        this.stopSessionCheckTimer();\r\n        this.ngZone.runOutsideAngular(() => {\r\n            this.sessionCheckTimer = setInterval(this.checkSession.bind(this), this.sessionCheckIntervall);\r\n        });\r\n    }\r\n    stopSessionCheckTimer() {\r\n        if (this.sessionCheckTimer) {\r\n            clearInterval(this.sessionCheckTimer);\r\n            this.sessionCheckTimer = null;\r\n        }\r\n    }\r\n    checkSession() {\r\n        const iframe = this.document.getElementById(this.sessionCheckIFrameName);\r\n        if (!iframe) {\r\n            this.logger.warn('checkSession did not find iframe', this.sessionCheckIFrameName);\r\n        }\r\n        const sessionState = this.getSessionState();\r\n        if (!sessionState) {\r\n            this.stopSessionCheckTimer();\r\n        }\r\n        const message = this.clientId + ' ' + sessionState;\r\n        iframe.contentWindow.postMessage(message, this.issuer);\r\n    }\r\n    createLoginUrl(state = '', loginHint = '', customRedirectUri = '', noPrompt = false, params = {}) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const that = this;\r\n            let redirectUri;\r\n            if (customRedirectUri) {\r\n                redirectUri = customRedirectUri;\r\n            }\r\n            else {\r\n                redirectUri = this.redirectUri;\r\n            }\r\n            const nonce = yield this.createAndSaveNonce();\r\n            if (state) {\r\n                state =\r\n                    nonce + this.config.nonceStateSeparator + encodeURIComponent(state);\r\n            }\r\n            else {\r\n                state = nonce;\r\n            }\r\n            if (!this.requestAccessToken && !this.oidc) {\r\n                throw new Error('Either requestAccessToken or oidc or both must be true');\r\n            }\r\n            if (this.config.responseType) {\r\n                this.responseType = this.config.responseType;\r\n            }\r\n            else {\r\n                if (this.oidc && this.requestAccessToken) {\r\n                    this.responseType = 'id_token token';\r\n                }\r\n                else if (this.oidc && !this.requestAccessToken) {\r\n                    this.responseType = 'id_token';\r\n                }\r\n                else {\r\n                    this.responseType = 'token';\r\n                }\r\n            }\r\n            const seperationChar = that.loginUrl.indexOf('?') > -1 ? '&' : '?';\r\n            let scope = that.scope;\r\n            if (this.oidc && !scope.match(/(^|\\s)openid($|\\s)/)) {\r\n                scope = 'openid ' + scope;\r\n            }\r\n            let url = that.loginUrl +\r\n                seperationChar +\r\n                'response_type=' +\r\n                encodeURIComponent(that.responseType) +\r\n                '&client_id=' +\r\n                encodeURIComponent(that.clientId) +\r\n                '&state=' +\r\n                encodeURIComponent(state) +\r\n                '&redirect_uri=' +\r\n                encodeURIComponent(redirectUri) +\r\n                '&scope=' +\r\n                encodeURIComponent(scope);\r\n            if (this.responseType.includes('code') && !this.disablePKCE) {\r\n                const [challenge, verifier] = yield this.createChallangeVerifierPairForPKCE();\r\n                if (this.saveNoncesInLocalStorage &&\r\n                    typeof window['localStorage'] !== 'undefined') {\r\n                    localStorage.setItem('PKCE_verifier', verifier);\r\n                }\r\n                else {\r\n                    this._storage.setItem('PKCE_verifier', verifier);\r\n                }\r\n                url += '&code_challenge=' + challenge;\r\n                url += '&code_challenge_method=S256';\r\n            }\r\n            if (loginHint) {\r\n                url += '&login_hint=' + encodeURIComponent(loginHint);\r\n            }\r\n            if (that.resource) {\r\n                url += '&resource=' + encodeURIComponent(that.resource);\r\n            }\r\n            if (that.oidc) {\r\n                url += '&nonce=' + encodeURIComponent(nonce);\r\n            }\r\n            if (noPrompt) {\r\n                url += '&prompt=none';\r\n            }\r\n            for (const key of Object.keys(params)) {\r\n                url +=\r\n                    '&' + encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);\r\n            }\r\n            if (this.customQueryParams) {\r\n                for (const key of Object.getOwnPropertyNames(this.customQueryParams)) {\r\n                    url +=\r\n                        '&' + key + '=' + encodeURIComponent(this.customQueryParams[key]);\r\n                }\r\n            }\r\n            return url;\r\n        });\r\n    }\r\n    initImplicitFlowInternal(additionalState = '', params = '') {\r\n        if (this.inImplicitFlow) {\r\n            return;\r\n        }\r\n        this.inImplicitFlow = true;\r\n        if (!this.validateUrlForHttps(this.loginUrl)) {\r\n            throw new Error(\"loginUrl  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\");\r\n        }\r\n        let addParams = {};\r\n        let loginHint = null;\r\n        if (typeof params === 'string') {\r\n            loginHint = params;\r\n        }\r\n        else if (typeof params === 'object') {\r\n            addParams = params;\r\n        }\r\n        this.createLoginUrl(additionalState, loginHint, null, false, addParams)\r\n            .then(this.config.openUri)\r\n            .catch((error) => {\r\n            console.error('Error in initImplicitFlow', error);\r\n            this.inImplicitFlow = false;\r\n        });\r\n    }\r\n    /**\r\n     * Starts the implicit flow and redirects to user to\r\n     * the auth servers' login url.\r\n     *\r\n     * @param additionalState Optional state that is passed around.\r\n     *  You'll find this state in the property `state` after `tryLogin` logged in the user.\r\n     * @param params Hash with additional parameter. If it is a string, it is used for the\r\n     *               parameter loginHint (for the sake of compatibility with former versions)\r\n     */\r\n    initImplicitFlow(additionalState = '', params = '') {\r\n        if (this.loginUrl !== '') {\r\n            this.initImplicitFlowInternal(additionalState, params);\r\n        }\r\n        else {\r\n            this.events\r\n                .pipe(filter((e) => e.type === 'discovery_document_loaded'))\r\n                .subscribe((_) => this.initImplicitFlowInternal(additionalState, params));\r\n        }\r\n    }\r\n    /**\r\n     * Reset current implicit flow\r\n     *\r\n     * @description This method allows resetting the current implict flow in order to be initialized again.\r\n     */\r\n    resetImplicitFlow() {\r\n        this.inImplicitFlow = false;\r\n    }\r\n    callOnTokenReceivedIfExists(options) {\r\n        const that = this;\r\n        if (options.onTokenReceived) {\r\n            const tokenParams = {\r\n                idClaims: that.getIdentityClaims(),\r\n                idToken: that.getIdToken(),\r\n                accessToken: that.getAccessToken(),\r\n                state: that.state,\r\n            };\r\n            options.onTokenReceived(tokenParams);\r\n        }\r\n    }\r\n    storeAccessTokenResponse(accessToken, refreshToken, expiresIn, grantedScopes, customParameters) {\r\n        this._storage.setItem('access_token', accessToken);\r\n        if (grantedScopes && !Array.isArray(grantedScopes)) {\r\n            this._storage.setItem('granted_scopes', JSON.stringify(grantedScopes.split(' ')));\r\n        }\r\n        else if (grantedScopes && Array.isArray(grantedScopes)) {\r\n            this._storage.setItem('granted_scopes', JSON.stringify(grantedScopes));\r\n        }\r\n        this._storage.setItem('access_token_stored_at', '' + this.dateTimeService.now());\r\n        if (expiresIn) {\r\n            const expiresInMilliSeconds = expiresIn * 1000;\r\n            const now = this.dateTimeService.new();\r\n            const expiresAt = now.getTime() + expiresInMilliSeconds;\r\n            this._storage.setItem('expires_at', '' + expiresAt);\r\n        }\r\n        if (refreshToken) {\r\n            this._storage.setItem('refresh_token', refreshToken);\r\n        }\r\n        if (customParameters) {\r\n            customParameters.forEach((value, key) => {\r\n                this._storage.setItem(key, value);\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Delegates to tryLoginImplicitFlow for the sake of competability\r\n     * @param options Optional options.\r\n     */\r\n    tryLogin(options = null) {\r\n        if (this.config.responseType === 'code') {\r\n            return this.tryLoginCodeFlow(options).then((_) => true);\r\n        }\r\n        else {\r\n            return this.tryLoginImplicitFlow(options);\r\n        }\r\n    }\r\n    parseQueryString(queryString) {\r\n        if (!queryString || queryString.length === 0) {\r\n            return {};\r\n        }\r\n        if (queryString.charAt(0) === '?') {\r\n            queryString = queryString.substr(1);\r\n        }\r\n        return this.urlHelper.parseQueryString(queryString);\r\n    }\r\n    tryLoginCodeFlow(options = null) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            options = options || {};\r\n            const querySource = options.customHashFragment\r\n                ? options.customHashFragment.substring(1)\r\n                : window.location.search;\r\n            const parts = this.getCodePartsFromUrl(querySource);\r\n            const code = parts['code'];\r\n            const state = parts['state'];\r\n            const sessionState = parts['session_state'];\r\n            if (!options.preventClearHashAfterLogin) {\r\n                const href = location.origin +\r\n                    location.pathname +\r\n                    location.search\r\n                        .replace(/code=[^&\\$]*/, '')\r\n                        .replace(/scope=[^&\\$]*/, '')\r\n                        .replace(/state=[^&\\$]*/, '')\r\n                        .replace(/session_state=[^&\\$]*/, '')\r\n                        .replace(/^\\?&/, '?')\r\n                        .replace(/&$/, '')\r\n                        .replace(/^\\?$/, '')\r\n                        .replace(/&+/g, '&')\r\n                        .replace(/\\?&/, '?')\r\n                        .replace(/\\?$/, '') +\r\n                    location.hash;\r\n                history.replaceState(null, window.name, href);\r\n            }\r\n            let [nonceInState, userState] = this.parseState(state);\r\n            this.state = userState;\r\n            if (parts['error']) {\r\n                this.debug('error trying to login');\r\n                this.handleLoginError(options, parts);\r\n                const err = new OAuthErrorEvent('code_error', {}, parts);\r\n                this.eventsSubject.next(err);\r\n                return Promise.reject(err);\r\n            }\r\n            if (!options.disableNonceCheck) {\r\n                if (!nonceInState) {\r\n                    this.saveRequestedRoute();\r\n                    return Promise.resolve();\r\n                }\r\n                if (!options.disableOAuth2StateCheck) {\r\n                    const success = this.validateNonce(nonceInState);\r\n                    if (!success) {\r\n                        const event = new OAuthErrorEvent('invalid_nonce_in_state', null);\r\n                        this.eventsSubject.next(event);\r\n                        return Promise.reject(event);\r\n                    }\r\n                }\r\n            }\r\n            this.storeSessionState(sessionState);\r\n            if (code) {\r\n                yield this.getTokenFromCode(code, options);\r\n                this.restoreRequestedRoute();\r\n                return Promise.resolve();\r\n            }\r\n            else {\r\n                return Promise.resolve();\r\n            }\r\n        });\r\n    }\r\n    saveRequestedRoute() {\r\n        if (this.config.preserveRequestedRoute) {\r\n            this._storage.setItem('requested_route', window.location.pathname + window.location.search);\r\n        }\r\n    }\r\n    restoreRequestedRoute() {\r\n        const requestedRoute = this._storage.getItem('requested_route');\r\n        if (requestedRoute) {\r\n            history.replaceState(null, '', window.location.origin + requestedRoute);\r\n        }\r\n    }\r\n    /**\r\n     * Retrieve the returned auth code from the redirect uri that has been called.\r\n     * If required also check hash, as we could use hash location strategy.\r\n     */\r\n    getCodePartsFromUrl(queryString) {\r\n        if (!queryString || queryString.length === 0) {\r\n            return this.urlHelper.getHashFragmentParams();\r\n        }\r\n        // normalize query string\r\n        if (queryString.charAt(0) === '?') {\r\n            queryString = queryString.substr(1);\r\n        }\r\n        return this.urlHelper.parseQueryString(queryString);\r\n    }\r\n    /**\r\n     * Get token using an intermediate code. Works for the Authorization Code flow.\r\n     */\r\n    getTokenFromCode(code, options) {\r\n        let params = new HttpParams({ encoder: new WebHttpUrlEncodingCodec() })\r\n            .set('grant_type', 'authorization_code')\r\n            .set('code', code)\r\n            .set('redirect_uri', options.customRedirectUri || this.redirectUri);\r\n        if (!this.disablePKCE) {\r\n            let PKCEVerifier;\r\n            if (this.saveNoncesInLocalStorage &&\r\n                typeof window['localStorage'] !== 'undefined') {\r\n                PKCEVerifier = localStorage.getItem('PKCE_verifier');\r\n            }\r\n            else {\r\n                PKCEVerifier = this._storage.getItem('PKCE_verifier');\r\n            }\r\n            if (!PKCEVerifier) {\r\n                console.warn('No PKCE verifier found in oauth storage!');\r\n            }\r\n            else {\r\n                params = params.set('code_verifier', PKCEVerifier);\r\n            }\r\n        }\r\n        return this.fetchAndProcessToken(params, options);\r\n    }\r\n    fetchAndProcessToken(params, options) {\r\n        options = options || {};\r\n        this.assertUrlNotNullAndCorrectProtocol(this.tokenEndpoint, 'tokenEndpoint');\r\n        let headers = new HttpHeaders().set('Content-Type', 'application/x-www-form-urlencoded');\r\n        if (this.useHttpBasicAuth) {\r\n            const header = btoa(`${this.clientId}:${this.dummyClientSecret}`);\r\n            headers = headers.set('Authorization', 'Basic ' + header);\r\n        }\r\n        if (!this.useHttpBasicAuth) {\r\n            params = params.set('client_id', this.clientId);\r\n        }\r\n        if (!this.useHttpBasicAuth && this.dummyClientSecret) {\r\n            params = params.set('client_secret', this.dummyClientSecret);\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            if (this.customQueryParams) {\r\n                for (let key of Object.getOwnPropertyNames(this.customQueryParams)) {\r\n                    params = params.set(key, this.customQueryParams[key]);\r\n                }\r\n            }\r\n            this.http\r\n                .post(this.tokenEndpoint, params, { headers })\r\n                .subscribe((tokenResponse) => {\r\n                this.debug('refresh tokenResponse', tokenResponse);\r\n                this.storeAccessTokenResponse(tokenResponse.access_token, tokenResponse.refresh_token, tokenResponse.expires_in ||\r\n                    this.fallbackAccessTokenExpirationTimeInSec, tokenResponse.scope, this.extractRecognizedCustomParameters(tokenResponse));\r\n                if (this.oidc && tokenResponse.id_token) {\r\n                    this.processIdToken(tokenResponse.id_token, tokenResponse.access_token, options.disableNonceCheck)\r\n                        .then((result) => {\r\n                        this.storeIdToken(result);\r\n                        this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\r\n                        this.eventsSubject.next(new OAuthSuccessEvent('token_refreshed'));\r\n                        resolve(tokenResponse);\r\n                    })\r\n                        .catch((reason) => {\r\n                        this.eventsSubject.next(new OAuthErrorEvent('token_validation_error', reason));\r\n                        console.error('Error validating tokens');\r\n                        console.error(reason);\r\n                        reject(reason);\r\n                    });\r\n                }\r\n                else {\r\n                    this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\r\n                    this.eventsSubject.next(new OAuthSuccessEvent('token_refreshed'));\r\n                    resolve(tokenResponse);\r\n                }\r\n            }, (err) => {\r\n                console.error('Error getting token', err);\r\n                this.eventsSubject.next(new OAuthErrorEvent('token_refresh_error', err));\r\n                reject(err);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Checks whether there are tokens in the hash fragment\r\n     * as a result of the implicit flow. These tokens are\r\n     * parsed, validated and used to sign the user in to the\r\n     * current client.\r\n     *\r\n     * @param options Optional options.\r\n     */\r\n    tryLoginImplicitFlow(options = null) {\r\n        options = options || {};\r\n        let parts;\r\n        if (options.customHashFragment) {\r\n            parts = this.urlHelper.getHashFragmentParams(options.customHashFragment);\r\n        }\r\n        else {\r\n            parts = this.urlHelper.getHashFragmentParams();\r\n        }\r\n        this.debug('parsed url', parts);\r\n        const state = parts['state'];\r\n        let [nonceInState, userState] = this.parseState(state);\r\n        this.state = userState;\r\n        if (parts['error']) {\r\n            this.debug('error trying to login');\r\n            this.handleLoginError(options, parts);\r\n            const err = new OAuthErrorEvent('token_error', {}, parts);\r\n            this.eventsSubject.next(err);\r\n            return Promise.reject(err);\r\n        }\r\n        const accessToken = parts['access_token'];\r\n        const idToken = parts['id_token'];\r\n        const sessionState = parts['session_state'];\r\n        const grantedScopes = parts['scope'];\r\n        if (!this.requestAccessToken && !this.oidc) {\r\n            return Promise.reject('Either requestAccessToken or oidc (or both) must be true.');\r\n        }\r\n        if (this.requestAccessToken && !accessToken) {\r\n            return Promise.resolve(false);\r\n        }\r\n        if (this.requestAccessToken && !options.disableOAuth2StateCheck && !state) {\r\n            return Promise.resolve(false);\r\n        }\r\n        if (this.oidc && !idToken) {\r\n            return Promise.resolve(false);\r\n        }\r\n        if (this.sessionChecksEnabled && !sessionState) {\r\n            this.logger.warn('session checks (Session Status Change Notification) ' +\r\n                'were activated in the configuration but the id_token ' +\r\n                'does not contain a session_state claim');\r\n        }\r\n        if (this.requestAccessToken && !options.disableNonceCheck) {\r\n            const success = this.validateNonce(nonceInState);\r\n            if (!success) {\r\n                const event = new OAuthErrorEvent('invalid_nonce_in_state', null);\r\n                this.eventsSubject.next(event);\r\n                return Promise.reject(event);\r\n            }\r\n        }\r\n        if (this.requestAccessToken) {\r\n            this.storeAccessTokenResponse(accessToken, null, parts['expires_in'] || this.fallbackAccessTokenExpirationTimeInSec, grantedScopes);\r\n        }\r\n        if (!this.oidc) {\r\n            this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\r\n            if (this.clearHashAfterLogin && !options.preventClearHashAfterLogin) {\r\n                this.clearLocationHash();\r\n            }\r\n            this.callOnTokenReceivedIfExists(options);\r\n            return Promise.resolve(true);\r\n        }\r\n        return this.processIdToken(idToken, accessToken, options.disableNonceCheck)\r\n            .then((result) => {\r\n            if (options.validationHandler) {\r\n                return options\r\n                    .validationHandler({\r\n                    accessToken: accessToken,\r\n                    idClaims: result.idTokenClaims,\r\n                    idToken: result.idToken,\r\n                    state: state,\r\n                })\r\n                    .then((_) => result);\r\n            }\r\n            return result;\r\n        })\r\n            .then((result) => {\r\n            this.storeIdToken(result);\r\n            this.storeSessionState(sessionState);\r\n            if (this.clearHashAfterLogin && !options.preventClearHashAfterLogin) {\r\n                this.clearLocationHash();\r\n            }\r\n            this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\r\n            this.callOnTokenReceivedIfExists(options);\r\n            this.inImplicitFlow = false;\r\n            return true;\r\n        })\r\n            .catch((reason) => {\r\n            this.eventsSubject.next(new OAuthErrorEvent('token_validation_error', reason));\r\n            this.logger.error('Error validating tokens');\r\n            this.logger.error(reason);\r\n            return Promise.reject(reason);\r\n        });\r\n    }\r\n    parseState(state) {\r\n        let nonce = state;\r\n        let userState = '';\r\n        if (state) {\r\n            const idx = state.indexOf(this.config.nonceStateSeparator);\r\n            if (idx > -1) {\r\n                nonce = state.substr(0, idx);\r\n                userState = state.substr(idx + this.config.nonceStateSeparator.length);\r\n            }\r\n        }\r\n        return [nonce, userState];\r\n    }\r\n    validateNonce(nonceInState) {\r\n        let savedNonce;\r\n        if (this.saveNoncesInLocalStorage &&\r\n            typeof window['localStorage'] !== 'undefined') {\r\n            savedNonce = localStorage.getItem('nonce');\r\n        }\r\n        else {\r\n            savedNonce = this._storage.getItem('nonce');\r\n        }\r\n        if (savedNonce !== nonceInState) {\r\n            const err = 'Validating access_token failed, wrong state/nonce.';\r\n            console.error(err, savedNonce, nonceInState);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    storeIdToken(idToken) {\r\n        this._storage.setItem('id_token', idToken.idToken);\r\n        this._storage.setItem('id_token_claims_obj', idToken.idTokenClaimsJson);\r\n        this._storage.setItem('id_token_expires_at', '' + idToken.idTokenExpiresAt);\r\n        this._storage.setItem('id_token_stored_at', '' + this.dateTimeService.now());\r\n    }\r\n    storeSessionState(sessionState) {\r\n        this._storage.setItem('session_state', sessionState);\r\n    }\r\n    getSessionState() {\r\n        return this._storage.getItem('session_state');\r\n    }\r\n    handleLoginError(options, parts) {\r\n        if (options.onLoginError) {\r\n            options.onLoginError(parts);\r\n        }\r\n        if (this.clearHashAfterLogin && !options.preventClearHashAfterLogin) {\r\n            this.clearLocationHash();\r\n        }\r\n    }\r\n    getClockSkewInMsec(defaultSkewMsc = 600000) {\r\n        if (!this.clockSkewInSec && this.clockSkewInSec !== 0) {\r\n            return defaultSkewMsc;\r\n        }\r\n        return this.clockSkewInSec * 1000;\r\n    }\r\n    /**\r\n     * @ignore\r\n     */\r\n    processIdToken(idToken, accessToken, skipNonceCheck = false) {\r\n        const tokenParts = idToken.split('.');\r\n        const headerBase64 = this.padBase64(tokenParts[0]);\r\n        const headerJson = b64DecodeUnicode(headerBase64);\r\n        const header = JSON.parse(headerJson);\r\n        const claimsBase64 = this.padBase64(tokenParts[1]);\r\n        const claimsJson = b64DecodeUnicode(claimsBase64);\r\n        const claims = JSON.parse(claimsJson);\r\n        let savedNonce;\r\n        if (this.saveNoncesInLocalStorage &&\r\n            typeof window['localStorage'] !== 'undefined') {\r\n            savedNonce = localStorage.getItem('nonce');\r\n        }\r\n        else {\r\n            savedNonce = this._storage.getItem('nonce');\r\n        }\r\n        if (Array.isArray(claims.aud)) {\r\n            if (claims.aud.every((v) => v !== this.clientId)) {\r\n                const err = 'Wrong audience: ' + claims.aud.join(',');\r\n                this.logger.warn(err);\r\n                return Promise.reject(err);\r\n            }\r\n        }\r\n        else {\r\n            if (claims.aud !== this.clientId) {\r\n                const err = 'Wrong audience: ' + claims.aud;\r\n                this.logger.warn(err);\r\n                return Promise.reject(err);\r\n            }\r\n        }\r\n        if (!claims.sub) {\r\n            const err = 'No sub claim in id_token';\r\n            this.logger.warn(err);\r\n            return Promise.reject(err);\r\n        }\r\n        /* For now, we only check whether the sub against\r\n         * silentRefreshSubject when sessionChecksEnabled is on\r\n         * We will reconsider in a later version to do this\r\n         * in every other case too.\r\n         */\r\n        if (this.sessionChecksEnabled &&\r\n            this.silentRefreshSubject &&\r\n            this.silentRefreshSubject !== claims['sub']) {\r\n            const err = 'After refreshing, we got an id_token for another user (sub). ' +\r\n                `Expected sub: ${this.silentRefreshSubject}, received sub: ${claims['sub']}`;\r\n            this.logger.warn(err);\r\n            return Promise.reject(err);\r\n        }\r\n        if (!claims.iat) {\r\n            const err = 'No iat claim in id_token';\r\n            this.logger.warn(err);\r\n            return Promise.reject(err);\r\n        }\r\n        if (!this.skipIssuerCheck && claims.iss !== this.issuer) {\r\n            const err = 'Wrong issuer: ' + claims.iss;\r\n            this.logger.warn(err);\r\n            return Promise.reject(err);\r\n        }\r\n        if (!skipNonceCheck && claims.nonce !== savedNonce) {\r\n            const err = 'Wrong nonce: ' + claims.nonce;\r\n            this.logger.warn(err);\r\n            return Promise.reject(err);\r\n        }\r\n        // at_hash is not applicable to authorization code flow\r\n        // addressing https://github.com/manfredsteyer/angular-oauth2-oidc/issues/661\r\n        // i.e. Based on spec the at_hash check is only true for implicit code flow on Ping Federate\r\n        // https://www.pingidentity.com/developer/en/resources/openid-connect-developers-guide.html\r\n        if (this.hasOwnProperty('responseType') &&\r\n            (this.responseType === 'code' || this.responseType === 'id_token')) {\r\n            this.disableAtHashCheck = true;\r\n        }\r\n        if (!this.disableAtHashCheck &&\r\n            this.requestAccessToken &&\r\n            !claims['at_hash']) {\r\n            const err = 'An at_hash is needed!';\r\n            this.logger.warn(err);\r\n            return Promise.reject(err);\r\n        }\r\n        const now = this.dateTimeService.now();\r\n        const issuedAtMSec = claims.iat * 1000;\r\n        const expiresAtMSec = claims.exp * 1000;\r\n        const clockSkewInMSec = this.getClockSkewInMsec(); // (this.getClockSkewInMsec() || 600) * 1000;\r\n        if (issuedAtMSec - clockSkewInMSec >= now ||\r\n            expiresAtMSec + clockSkewInMSec - this.decreaseExpirationBySec <= now) {\r\n            const err = 'Token has expired';\r\n            console.error(err);\r\n            console.error({\r\n                now: now,\r\n                issuedAtMSec: issuedAtMSec,\r\n                expiresAtMSec: expiresAtMSec,\r\n            });\r\n            return Promise.reject(err);\r\n        }\r\n        const validationParams = {\r\n            accessToken: accessToken,\r\n            idToken: idToken,\r\n            jwks: this.jwks,\r\n            idTokenClaims: claims,\r\n            idTokenHeader: header,\r\n            loadKeys: () => this.loadJwks(),\r\n        };\r\n        if (this.disableAtHashCheck) {\r\n            return this.checkSignature(validationParams).then((_) => {\r\n                const result = {\r\n                    idToken: idToken,\r\n                    idTokenClaims: claims,\r\n                    idTokenClaimsJson: claimsJson,\r\n                    idTokenHeader: header,\r\n                    idTokenHeaderJson: headerJson,\r\n                    idTokenExpiresAt: expiresAtMSec,\r\n                };\r\n                return result;\r\n            });\r\n        }\r\n        return this.checkAtHash(validationParams).then((atHashValid) => {\r\n            if (!this.disableAtHashCheck && this.requestAccessToken && !atHashValid) {\r\n                const err = 'Wrong at_hash';\r\n                this.logger.warn(err);\r\n                return Promise.reject(err);\r\n            }\r\n            return this.checkSignature(validationParams).then((_) => {\r\n                const atHashCheckEnabled = !this.disableAtHashCheck;\r\n                const result = {\r\n                    idToken: idToken,\r\n                    idTokenClaims: claims,\r\n                    idTokenClaimsJson: claimsJson,\r\n                    idTokenHeader: header,\r\n                    idTokenHeaderJson: headerJson,\r\n                    idTokenExpiresAt: expiresAtMSec,\r\n                };\r\n                if (atHashCheckEnabled) {\r\n                    return this.checkAtHash(validationParams).then((atHashValid) => {\r\n                        if (this.requestAccessToken && !atHashValid) {\r\n                            const err = 'Wrong at_hash';\r\n                            this.logger.warn(err);\r\n                            return Promise.reject(err);\r\n                        }\r\n                        else {\r\n                            return result;\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    return result;\r\n                }\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Returns the received claims about the user.\r\n     */\r\n    getIdentityClaims() {\r\n        const claims = this._storage.getItem('id_token_claims_obj');\r\n        if (!claims) {\r\n            return null;\r\n        }\r\n        return JSON.parse(claims);\r\n    }\r\n    /**\r\n     * Returns the granted scopes from the server.\r\n     */\r\n    getGrantedScopes() {\r\n        const scopes = this._storage.getItem('granted_scopes');\r\n        if (!scopes) {\r\n            return null;\r\n        }\r\n        return JSON.parse(scopes);\r\n    }\r\n    /**\r\n     * Returns the current id_token.\r\n     */\r\n    getIdToken() {\r\n        return this._storage ? this._storage.getItem('id_token') : null;\r\n    }\r\n    padBase64(base64data) {\r\n        while (base64data.length % 4 !== 0) {\r\n            base64data += '=';\r\n        }\r\n        return base64data;\r\n    }\r\n    /**\r\n     * Returns the current access_token.\r\n     */\r\n    getAccessToken() {\r\n        return this._storage ? this._storage.getItem('access_token') : null;\r\n    }\r\n    getRefreshToken() {\r\n        return this._storage ? this._storage.getItem('refresh_token') : null;\r\n    }\r\n    /**\r\n     * Returns the expiration date of the access_token\r\n     * as milliseconds since 1970.\r\n     */\r\n    getAccessTokenExpiration() {\r\n        if (!this._storage.getItem('expires_at')) {\r\n            return null;\r\n        }\r\n        return parseInt(this._storage.getItem('expires_at'), 10);\r\n    }\r\n    getAccessTokenStoredAt() {\r\n        return parseInt(this._storage.getItem('access_token_stored_at'), 10);\r\n    }\r\n    getIdTokenStoredAt() {\r\n        return parseInt(this._storage.getItem('id_token_stored_at'), 10);\r\n    }\r\n    /**\r\n     * Returns the expiration date of the id_token\r\n     * as milliseconds since 1970.\r\n     */\r\n    getIdTokenExpiration() {\r\n        if (!this._storage.getItem('id_token_expires_at')) {\r\n            return null;\r\n        }\r\n        return parseInt(this._storage.getItem('id_token_expires_at'), 10);\r\n    }\r\n    /**\r\n     * Checkes, whether there is a valid access_token.\r\n     */\r\n    hasValidAccessToken() {\r\n        if (this.getAccessToken()) {\r\n            const expiresAt = this._storage.getItem('expires_at');\r\n            const now = this.dateTimeService.new();\r\n            if (expiresAt &&\r\n                parseInt(expiresAt, 10) - this.decreaseExpirationBySec <\r\n                    now.getTime() - this.getClockSkewInMsec()) {\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Checks whether there is a valid id_token.\r\n     */\r\n    hasValidIdToken() {\r\n        if (this.getIdToken()) {\r\n            const expiresAt = this._storage.getItem('id_token_expires_at');\r\n            const now = this.dateTimeService.new();\r\n            if (expiresAt &&\r\n                parseInt(expiresAt, 10) - this.decreaseExpirationBySec <\r\n                    now.getTime() - this.getClockSkewInMsec()) {\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Retrieve a saved custom property of the TokenReponse object. Only if predefined in authconfig.\r\n     */\r\n    getCustomTokenResponseProperty(requestedProperty) {\r\n        return this._storage &&\r\n            this.config.customTokenParameters &&\r\n            this.config.customTokenParameters.indexOf(requestedProperty) >= 0 &&\r\n            this._storage.getItem(requestedProperty) !== null\r\n            ? JSON.parse(this._storage.getItem(requestedProperty))\r\n            : null;\r\n    }\r\n    /**\r\n     * Returns the auth-header that can be used\r\n     * to transmit the access_token to a service\r\n     */\r\n    authorizationHeader() {\r\n        return 'Bearer ' + this.getAccessToken();\r\n    }\r\n    logOut(customParameters = {}, state = '') {\r\n        let noRedirectToLogoutUrl = false;\r\n        if (typeof customParameters === 'boolean') {\r\n            noRedirectToLogoutUrl = customParameters;\r\n            customParameters = {};\r\n        }\r\n        const id_token = this.getIdToken();\r\n        this._storage.removeItem('access_token');\r\n        this._storage.removeItem('id_token');\r\n        this._storage.removeItem('refresh_token');\r\n        if (this.saveNoncesInLocalStorage) {\r\n            localStorage.removeItem('nonce');\r\n            localStorage.removeItem('PKCE_verifier');\r\n        }\r\n        else {\r\n            this._storage.removeItem('nonce');\r\n            this._storage.removeItem('PKCE_verifier');\r\n        }\r\n        this._storage.removeItem('expires_at');\r\n        this._storage.removeItem('id_token_claims_obj');\r\n        this._storage.removeItem('id_token_expires_at');\r\n        this._storage.removeItem('id_token_stored_at');\r\n        this._storage.removeItem('access_token_stored_at');\r\n        this._storage.removeItem('granted_scopes');\r\n        this._storage.removeItem('session_state');\r\n        if (this.config.customTokenParameters) {\r\n            this.config.customTokenParameters.forEach((customParam) => this._storage.removeItem(customParam));\r\n        }\r\n        this.silentRefreshSubject = null;\r\n        this.eventsSubject.next(new OAuthInfoEvent('logout'));\r\n        if (!this.logoutUrl) {\r\n            return;\r\n        }\r\n        if (noRedirectToLogoutUrl) {\r\n            return;\r\n        }\r\n        // if (!id_token && !this.postLogoutRedirectUri) {\r\n        //   return;\r\n        // }\r\n        let logoutUrl;\r\n        if (!this.validateUrlForHttps(this.logoutUrl)) {\r\n            throw new Error(\"logoutUrl  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\");\r\n        }\r\n        // For backward compatibility\r\n        if (this.logoutUrl.indexOf('{{') > -1) {\r\n            logoutUrl = this.logoutUrl\r\n                .replace(/\\{\\{id_token\\}\\}/, encodeURIComponent(id_token))\r\n                .replace(/\\{\\{client_id\\}\\}/, encodeURIComponent(this.clientId));\r\n        }\r\n        else {\r\n            let params = new HttpParams({ encoder: new WebHttpUrlEncodingCodec() });\r\n            if (id_token) {\r\n                params = params.set('id_token_hint', id_token);\r\n            }\r\n            const postLogoutUrl = this.postLogoutRedirectUri ||\r\n                (this.redirectUriAsPostLogoutRedirectUriFallback && this.redirectUri) ||\r\n                '';\r\n            if (postLogoutUrl) {\r\n                params = params.set('post_logout_redirect_uri', postLogoutUrl);\r\n                if (state) {\r\n                    params = params.set('state', state);\r\n                }\r\n            }\r\n            for (let key in customParameters) {\r\n                params = params.set(key, customParameters[key]);\r\n            }\r\n            logoutUrl =\r\n                this.logoutUrl +\r\n                    (this.logoutUrl.indexOf('?') > -1 ? '&' : '?') +\r\n                    params.toString();\r\n        }\r\n        this.config.openUri(logoutUrl);\r\n    }\r\n    /**\r\n     * @ignore\r\n     */\r\n    createAndSaveNonce() {\r\n        const that = this;\r\n        return this.createNonce().then(function (nonce) {\r\n            // Use localStorage for nonce if possible\r\n            // localStorage is the only storage who survives a\r\n            // redirect in ALL browsers (also IE)\r\n            // Otherwiese we'd force teams who have to support\r\n            // IE into using localStorage for everything\r\n            if (that.saveNoncesInLocalStorage &&\r\n                typeof window['localStorage'] !== 'undefined') {\r\n                localStorage.setItem('nonce', nonce);\r\n            }\r\n            else {\r\n                that._storage.setItem('nonce', nonce);\r\n            }\r\n            return nonce;\r\n        });\r\n    }\r\n    /**\r\n     * @ignore\r\n     */\r\n    ngOnDestroy() {\r\n        this.clearAccessTokenTimer();\r\n        this.clearIdTokenTimer();\r\n        this.removeSilentRefreshEventListener();\r\n        const silentRefreshFrame = this.document.getElementById(this.silentRefreshIFrameName);\r\n        if (silentRefreshFrame) {\r\n            silentRefreshFrame.remove();\r\n        }\r\n        this.stopSessionCheckTimer();\r\n        this.removeSessionCheckEventListener();\r\n        const sessionCheckFrame = this.document.getElementById(this.sessionCheckIFrameName);\r\n        if (sessionCheckFrame) {\r\n            sessionCheckFrame.remove();\r\n        }\r\n    }\r\n    createNonce() {\r\n        return new Promise((resolve) => {\r\n            if (this.rngUrl) {\r\n                throw new Error('createNonce with rng-web-api has not been implemented so far');\r\n            }\r\n            /*\r\n             * This alphabet is from:\r\n             * https://tools.ietf.org/html/rfc7636#section-4.1\r\n             *\r\n             * [A-Z] / [a-z] / [0-9] / \"-\" / \".\" / \"_\" / \"~\"\r\n             */\r\n            const unreserved = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';\r\n            let size = 45;\r\n            let id = '';\r\n            const crypto = typeof self === 'undefined' ? null : self.crypto || self['msCrypto'];\r\n            if (crypto) {\r\n                let bytes = new Uint8Array(size);\r\n                crypto.getRandomValues(bytes);\r\n                // Needed for IE\r\n                if (!bytes.map) {\r\n                    bytes.map = Array.prototype.map;\r\n                }\r\n                bytes = bytes.map((x) => unreserved.charCodeAt(x % unreserved.length));\r\n                id = String.fromCharCode.apply(null, bytes);\r\n            }\r\n            else {\r\n                while (0 < size--) {\r\n                    id += unreserved[(Math.random() * unreserved.length) | 0];\r\n                }\r\n            }\r\n            resolve(base64UrlEncode(id));\r\n        });\r\n    }\r\n    checkAtHash(params) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this.tokenValidationHandler) {\r\n                this.logger.warn('No tokenValidationHandler configured. Cannot check at_hash.');\r\n                return true;\r\n            }\r\n            return this.tokenValidationHandler.validateAtHash(params);\r\n        });\r\n    }\r\n    checkSignature(params) {\r\n        if (!this.tokenValidationHandler) {\r\n            this.logger.warn('No tokenValidationHandler configured. Cannot check signature.');\r\n            return Promise.resolve(null);\r\n        }\r\n        return this.tokenValidationHandler.validateSignature(params);\r\n    }\r\n    /**\r\n     * Start the implicit flow or the code flow,\r\n     * depending on your configuration.\r\n     */\r\n    initLoginFlow(additionalState = '', params = {}) {\r\n        if (this.responseType === 'code') {\r\n            return this.initCodeFlow(additionalState, params);\r\n        }\r\n        else {\r\n            return this.initImplicitFlow(additionalState, params);\r\n        }\r\n    }\r\n    /**\r\n     * Starts the authorization code flow and redirects to user to\r\n     * the auth servers login url.\r\n     */\r\n    initCodeFlow(additionalState = '', params = {}) {\r\n        if (this.loginUrl !== '') {\r\n            this.initCodeFlowInternal(additionalState, params);\r\n        }\r\n        else {\r\n            this.events\r\n                .pipe(filter((e) => e.type === 'discovery_document_loaded'))\r\n                .subscribe((_) => this.initCodeFlowInternal(additionalState, params));\r\n        }\r\n    }\r\n    initCodeFlowInternal(additionalState = '', params = {}) {\r\n        if (!this.validateUrlForHttps(this.loginUrl)) {\r\n            throw new Error(\"loginUrl  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\");\r\n        }\r\n        let addParams = {};\r\n        let loginHint = null;\r\n        if (typeof params === 'string') {\r\n            loginHint = params;\r\n        }\r\n        else if (typeof params === 'object') {\r\n            addParams = params;\r\n        }\r\n        this.createLoginUrl(additionalState, loginHint, null, false, addParams)\r\n            .then(this.config.openUri)\r\n            .catch((error) => {\r\n            console.error('Error in initAuthorizationCodeFlow');\r\n            console.error(error);\r\n        });\r\n    }\r\n    createChallangeVerifierPairForPKCE() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this.crypto) {\r\n                throw new Error('PKCE support for code flow needs a CryptoHander. Did you import the OAuthModule using forRoot() ?');\r\n            }\r\n            const verifier = yield this.createNonce();\r\n            const challengeRaw = yield this.crypto.calcHash(verifier, 'sha-256');\r\n            const challenge = base64UrlEncode(challengeRaw);\r\n            return [challenge, verifier];\r\n        });\r\n    }\r\n    extractRecognizedCustomParameters(tokenResponse) {\r\n        let foundParameters = new Map();\r\n        if (!this.config.customTokenParameters) {\r\n            return foundParameters;\r\n        }\r\n        this.config.customTokenParameters.forEach((recognizedParameter) => {\r\n            if (tokenResponse[recognizedParameter]) {\r\n                foundParameters.set(recognizedParameter, JSON.stringify(tokenResponse[recognizedParameter]));\r\n            }\r\n        });\r\n        return foundParameters;\r\n    }\r\n    /**\r\n     * Revokes the auth token to secure the vulnarability\r\n     * of the token issued allowing the authorization server to clean\r\n     * up any security credentials associated with the authorization\r\n     */\r\n    revokeTokenAndLogout(customParameters = {}, ignoreCorsIssues = false) {\r\n        let revokeEndpoint = this.revocationEndpoint;\r\n        let accessToken = this.getAccessToken();\r\n        let refreshToken = this.getRefreshToken();\r\n        if (!accessToken) {\r\n            return Promise.resolve();\r\n        }\r\n        let params = new HttpParams({ encoder: new WebHttpUrlEncodingCodec() });\r\n        let headers = new HttpHeaders().set('Content-Type', 'application/x-www-form-urlencoded');\r\n        if (this.useHttpBasicAuth) {\r\n            const header = btoa(`${this.clientId}:${this.dummyClientSecret}`);\r\n            headers = headers.set('Authorization', 'Basic ' + header);\r\n        }\r\n        if (!this.useHttpBasicAuth) {\r\n            params = params.set('client_id', this.clientId);\r\n        }\r\n        if (!this.useHttpBasicAuth && this.dummyClientSecret) {\r\n            params = params.set('client_secret', this.dummyClientSecret);\r\n        }\r\n        if (this.customQueryParams) {\r\n            for (const key of Object.getOwnPropertyNames(this.customQueryParams)) {\r\n                params = params.set(key, this.customQueryParams[key]);\r\n            }\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            let revokeAccessToken;\r\n            let revokeRefreshToken;\r\n            if (accessToken) {\r\n                let revokationParams = params\r\n                    .set('token', accessToken)\r\n                    .set('token_type_hint', 'access_token');\r\n                revokeAccessToken = this.http.post(revokeEndpoint, revokationParams, { headers });\r\n            }\r\n            else {\r\n                revokeAccessToken = of(null);\r\n            }\r\n            if (refreshToken) {\r\n                let revokationParams = params\r\n                    .set('token', refreshToken)\r\n                    .set('token_type_hint', 'refresh_token');\r\n                revokeRefreshToken = this.http.post(revokeEndpoint, revokationParams, { headers });\r\n            }\r\n            else {\r\n                revokeRefreshToken = of(null);\r\n            }\r\n            if (ignoreCorsIssues) {\r\n                revokeAccessToken = revokeAccessToken.pipe(catchError((err) => {\r\n                    if (err.status === 0) {\r\n                        return of(null);\r\n                    }\r\n                    return throwError(err);\r\n                }));\r\n                revokeRefreshToken = revokeRefreshToken.pipe(catchError((err) => {\r\n                    if (err.status === 0) {\r\n                        return of(null);\r\n                    }\r\n                    return throwError(err);\r\n                }));\r\n            }\r\n            combineLatest([revokeAccessToken, revokeRefreshToken]).subscribe((res) => {\r\n                this.logOut(customParameters);\r\n                resolve(res);\r\n                this.logger.info('Token successfully revoked');\r\n            }, (err) => {\r\n                this.logger.error('Error revoking token', err);\r\n                this.eventsSubject.next(new OAuthErrorEvent('token_revoke_error', err));\r\n                reject(err);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Clear location.hash if it's present\r\n     */\r\n    clearLocationHash() {\r\n        // Checking for empty hash is necessary for Firefox\r\n        // as setting an empty hash to an empty string adds # to the URL\r\n        if (location.hash != '') {\r\n            location.hash = '';\r\n        }\r\n    }\r\n}\r\nOAuthService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: OAuthService, deps: [{ token: i0.NgZone }, { token: i1.HttpClient }, { token: OAuthStorage, optional: true }, { token: ValidationHandler, optional: true }, { token: AuthConfig, optional: true }, { token: UrlHelperService }, { token: OAuthLogger }, { token: HashHandler, optional: true }, { token: DOCUMENT }, { token: DateTimeProvider }], target: i0.ɵɵFactoryTarget.Injectable });\r\nOAuthService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: OAuthService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: OAuthService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () {\r\n        return [{ type: i0.NgZone }, { type: i1.HttpClient }, { type: OAuthStorage, decorators: [{\r\n                        type: Optional\r\n                    }] }, { type: ValidationHandler, decorators: [{\r\n                        type: Optional\r\n                    }] }, { type: AuthConfig, decorators: [{\r\n                        type: Optional\r\n                    }] }, { type: UrlHelperService }, { type: OAuthLogger }, { type: HashHandler, decorators: [{\r\n                        type: Optional\r\n                    }] }, { type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [DOCUMENT]\r\n                    }] }, { type: DateTimeProvider }];\r\n    } });\n\nclass OAuthResourceServerErrorHandler {\r\n}\r\nclass OAuthNoopResourceServerErrorHandler {\r\n    handleError(err) {\r\n        return throwError(err);\r\n    }\r\n}\n\nclass DefaultOAuthInterceptor {\r\n    constructor(oAuthService, errorHandler, moduleConfig) {\r\n        this.oAuthService = oAuthService;\r\n        this.errorHandler = errorHandler;\r\n        this.moduleConfig = moduleConfig;\r\n    }\r\n    checkUrl(url) {\r\n        if (this.moduleConfig.resourceServer.customUrlValidation) {\r\n            return this.moduleConfig.resourceServer.customUrlValidation(url);\r\n        }\r\n        if (this.moduleConfig.resourceServer.allowedUrls) {\r\n            return !!this.moduleConfig.resourceServer.allowedUrls.find((u) => url.toLowerCase().startsWith(u.toLowerCase()));\r\n        }\r\n        return true;\r\n    }\r\n    intercept(req, next) {\r\n        const url = req.url.toLowerCase();\r\n        if (!this.moduleConfig ||\r\n            !this.moduleConfig.resourceServer ||\r\n            !this.checkUrl(url)) {\r\n            return next.handle(req);\r\n        }\r\n        const sendAccessToken = this.moduleConfig.resourceServer.sendAccessToken;\r\n        if (!sendAccessToken) {\r\n            return next\r\n                .handle(req)\r\n                .pipe(catchError((err) => this.errorHandler.handleError(err)));\r\n        }\r\n        return merge(of(this.oAuthService.getAccessToken()).pipe(filter((token) => !!token)), this.oAuthService.events.pipe(filter((e) => e.type === 'token_received'), timeout(this.oAuthService.waitForTokenInMsec || 0), catchError((_) => of(null)), // timeout is not an error\r\n        map((_) => this.oAuthService.getAccessToken()))).pipe(take(1), mergeMap((token) => {\r\n            if (token) {\r\n                const header = 'Bearer ' + token;\r\n                const headers = req.headers.set('Authorization', header);\r\n                req = req.clone({ headers });\r\n            }\r\n            return next\r\n                .handle(req)\r\n                .pipe(catchError((err) => this.errorHandler.handleError(err)));\r\n        }));\r\n    }\r\n}\r\nDefaultOAuthInterceptor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: DefaultOAuthInterceptor, deps: [{ token: OAuthService }, { token: OAuthResourceServerErrorHandler }, { token: OAuthModuleConfig, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\r\nDefaultOAuthInterceptor.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: DefaultOAuthInterceptor });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: DefaultOAuthInterceptor, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () {\r\n        return [{ type: OAuthService }, { type: OAuthResourceServerErrorHandler }, { type: OAuthModuleConfig, decorators: [{\r\n                        type: Optional\r\n                    }] }];\r\n    } });\n\nfunction createDefaultLogger() {\r\n    return console;\r\n}\r\nfunction createDefaultStorage() {\r\n    return typeof sessionStorage !== 'undefined'\r\n        ? sessionStorage\r\n        : new MemoryStorage();\r\n}\n\nfunction provideOAuthClient(config = null, validationHandlerClass = NullValidationHandler) {\r\n    return makeEnvironmentProviders([\r\n        OAuthService,\r\n        UrlHelperService,\r\n        { provide: OAuthLogger, useFactory: createDefaultLogger },\r\n        { provide: OAuthStorage, useFactory: createDefaultStorage },\r\n        { provide: ValidationHandler, useClass: validationHandlerClass },\r\n        { provide: HashHandler, useClass: DefaultHashHandler },\r\n        {\r\n            provide: OAuthResourceServerErrorHandler,\r\n            useClass: OAuthNoopResourceServerErrorHandler,\r\n        },\r\n        { provide: OAuthModuleConfig, useValue: config },\r\n        {\r\n            provide: HTTP_INTERCEPTORS,\r\n            useClass: DefaultOAuthInterceptor,\r\n            multi: true,\r\n        },\r\n        { provide: DateTimeProvider, useClass: SystemDateTimeProvider },\r\n    ]);\r\n}\n\nclass OAuthModule {\r\n    static forRoot(config = null, validationHandlerClass = NullValidationHandler) {\r\n        return {\r\n            ngModule: OAuthModule,\r\n            providers: [provideOAuthClient(config, validationHandlerClass)],\r\n        };\r\n    }\r\n}\r\nOAuthModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: OAuthModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\r\nOAuthModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"15.0.0\", ngImport: i0, type: OAuthModule, imports: [CommonModule] });\r\nOAuthModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: OAuthModule, imports: [CommonModule] });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"15.0.0\", ngImport: i0, type: OAuthModule, decorators: [{\r\n            type: NgModule,\r\n            args: [{\r\n                    imports: [CommonModule],\r\n                    declarations: [],\r\n                    exports: [],\r\n                }]\r\n        }] });\n\nconst err = `PLEASE READ THIS CAREFULLY:\n\nBeginning with angular-oauth2-oidc version 9, the JwksValidationHandler\nhas been moved to an library of its own. If you need it for implementing\nOAuth2/OIDC **implicit flow**, please install it using npm:\n\n  npm i angular-oauth2-oidc-jwks --save\n\nAfter that, you can import it into your application:\n\n  import { JwksValidationHandler } from 'angular-oauth2-oidc-jwks';\n\nPlease note, that this dependency is not needed for the **code flow**,\nwhich is nowadays the **recommented** one for single page applications.\nThis also results in smaller bundle sizes.\n`;\r\n/**\r\n * This is just a dummy of the JwksValidationHandler\r\n * telling the users that the real one has been moved\r\n * to an library of its own, namely angular-oauth2-oidc-utils\r\n */\r\nclass JwksValidationHandler extends NullValidationHandler {\r\n    constructor() {\r\n        super();\r\n        console.error(err);\r\n    }\r\n}\n\nconst AUTH_CONFIG = new InjectionToken('AUTH_CONFIG');\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { AUTH_CONFIG, AbstractValidationHandler, AuthConfig, DateTimeProvider, DefaultHashHandler, DefaultOAuthInterceptor, HashHandler, JwksValidationHandler, LoginOptions, MemoryStorage, NullValidationHandler, OAuthErrorEvent, OAuthEvent, OAuthInfoEvent, OAuthLogger, OAuthModule, OAuthModuleConfig, OAuthNoopResourceServerErrorHandler, OAuthResourceServerConfig, OAuthResourceServerErrorHandler, OAuthService, OAuthStorage, OAuthSuccessEvent, ReceivedTokens, SystemDateTimeProvider, UrlHelperService, ValidationHandler, provideOAuthClient };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}